---
"title": "JVM"
category:
  - "summary"
tag:
  - "jvm"
---

## 总述

以一个最简单的『Hello world！』的运行实例来说，大概分为这么几个步骤：

1. 编写阶段：创建一个以『java』为后缀名的文件，并使用编辑器写入代码；
2. 编译阶段：使用jdk中的javac工具编译java文件，产生.class文件；
3. 运行阶段： 使用jdk中的java工具运行.class文件，控制台输出『Hello world！』




## 编译

- 编译器分类
- 编译器的优化
- 字节码运行方式
  - 解释运行
  	- 读一句执行一句
  - 编译运行
  	- 先将字节码编译成机器码，运行时直接执行机器码，只在运行时进行编译
  - 对比： 编译后的性能比解释运行的性能有数量级的提升

## 类的加载

- 加载过程
  - 加载： 从各渠道加载字节码文件，之后生成代表这个类的java.lang.Class对象，作为这个类在方法区各种信息的访问入口；
  - 链接
    - 验证
    - 准备
    - 解析
  - 初始化 
- 双亲委派
- 类加载器 
- API操作等

## JVM的内存结构

JVM的内存结构可以分为 运行期内存结构 和 GC视角下的内存模型；

- 运行期内存结构【存放内容、常见配置参数、异常；】
  - 线程私有
    - 虚拟机栈 
    - 本地方法栈 
    - 程序计数器 
    - 直接内存  
  - 线程共享 
    - Java堆 
    - 方法区
  - 对象探秘 
    - 对象的内存分布 
      - 对象头（包括哈希值、分代次数、持有的锁、偏向线程ID、偏向时间戳）
      - 实例数据（包括自身属性字段以及从父类继承来的属性字段等）
      - 对齐填充 
    - 对象的创建过程
      - 先进行逃逸分析。判断对象的分配是否需要优化，如栈上分配、标量替换、同步消除等；
      - 判断能否在方法区的常量池中找到该类的引用。如果没有找到，要先进行类加载过程；
      - 之后是分配内存。有两种方式，一种是空闲列表，一种是指针碰撞方式。
      - 处理好同步的问题。
      - 完成初始化。把对应的字段初始化成相关的零值；
      - 完成其他剩余信息的构造等。
    - 对象的升代策略
    - 对象的访问定位
      - 句柄池方式
      - 直接指针方式
- GC内存模型 
  - eden+s0+s1+old+永久代/元空间
  - minorgc、majorgc、FullGC
    - 当发现s0空间不足，就会在eden区进行一次YoungGC，把存活对象复制到s0区，如果发现s0区也无法存放，就会出发空间担保机制。
  - GC日志

## JVM中的垃圾回收

- 存活对象判断标准
  - 引用计数法
  - 可达性分析
    - 引用类型 
    - 可作为GCRoot的对象
- 垃圾回收算法 
  - 标记-清除
  - 标记-整理
  - 复制算法
- 垃圾回收器
  - 分类
    - Serial
      - 单线程回收，回收过程中会暂停所有用户线程，采用的是复制算法，是client模式下默认的收集器
    - ParallelNew
      - 并行执行，采用的也是复制算法，Server模式下的默认收集器，
    - ParalleScanvenge
    - SerialOld
    - CMS 
    - G1
  - 回收过程
  - 相关的配置参数
  - 优缺点分析
  - 实际使用
- OOM定位及排查


## JVM中的并发

- JMM模型及其特性、主存与工作内存之间的操作
- 线程状态及转化条件
- 线程安全（定义、实现方式）
- 锁优化方式及原理
- 性能优化思路


## 实战

一般情况下，Java应用部署上线时，除了要配置一些运行期内存大小的参数外，还会配置一些用来监控的JVM参数，如gclog、heapDump等。这些监控参数，用来后续生产过程中，遇到问题时的定位，也会用在GC监控，以及后续JVM的调优上。

根据JVM出现的问题的不同，把所出现的问题大概划归成两部分内容：

1. 业务异常： 就是JVM运行过程中抛出的一些OOM等异常。
2. JVM调优： 这类是可能不会报出具体的错误或异常信息，这类问题大多是由于一些配置参数不合适，导致JVM没有发挥其最大性能。

所以根据遇到的问题的不同，来采用不同的解决方式。

### 业务异常 

- 问题表现： 生产环境上，业务突然抛出异常，或者业务无法处理、业务响应超时等；业务日志中会出现异常栈信息；
- 问题产生的原因：这类异常大多是由程序员编码不规范而造成的。
- 问题解决的关键思路： 找到出现问题的业务代码
- 问题定位过程： 
  - 可以根据业务日志，直接定位到业务代码中；
  - 也可以分析dump文件；
- 总结
    - JVM配置合适的启动参数。如heapDumpOnErrorPath、 heapDumpOnError等；
    - 建立服务器资源监控及报警机制。如加入链路追踪、集群服务器监控、日志归集、短信电话等报警机制；
    - 要有严格的开发规范。例如在需求开发过程中，高级程序员或团队老鸟评审菜鸟的实现方案；
    - 上线前要经过代码Review和严格的测试。代码Review比如记录关键日志、不能查询全表数据、不能循环查数据库、List和Map使用时初始化其大小、IO资源使用完成后要关闭等，严格的测试比如开发人员的单元测试、集成测试、边界值测试等；
    - 遇到问题时，迅速响应。之后要进行总结，事故分析报告；

### JVM调优 

- 结论： 一般情况下，JVM是不需要进行调优的。
- 需要调优的场景： 
  - 经过长期监控后，发现JVM部分指标出现的异常。这些指标多是停顿时间或GC频率。
  - 部分业务场景需要支持高并发时，要压榨单节点的服务性能。
- 前置条件：
  - 需要建立长效的监控机制。比如接入监控和报警机制、打印GC日志等；
  - 并完成正常的性能指标的确定。比如一段时间后，什么服务器资源下+什么JVM配置参数下，JVM性能指标【吞吐量、GC日志、停顿时间等】大概是多少；
  - 监控到异常的性能指标。
- 问题产生的原因 
  - Java堆设置不合理
  - 业务较为独特，比如全部都是大对象，对象很快进入老年代；


<img style="border:1px red solid; display:block; margin:0 auto;" src="https://tianqingxiaozhu.oss-cn-shenzhen.aliyuncs.com/img/qrcode.jpg" alt="微信公众号" />


