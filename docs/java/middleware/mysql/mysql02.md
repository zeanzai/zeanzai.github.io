---
title: "基本理论"
category:
  - "middleware"
tag:
  - "数据库"
---

## 数据库的原子操作 

所谓原子操作，与操作系统中的『原语』的概念类似，最大的特点就是不具备中断行，简单来说就是没有中间结果状态，要么成功，要么失败，只有二元性，不具备中间状态。几乎所有的数据库都具有CRUD四个原子操作。

## 事务及其特性

所谓事务，就是一组原子操作的组合。它满足四个特性，这四个特性也被称为事务特性，即ACID。原子性、一致性、隔离性、持久性。

- `A-原子性`，事务中的每一个操作都具备原子性，由多个这样的原子操作组成的事务也具备原子性，即这组原子操作要么全部成功，要么全部失败，不可能存在一部分操作成功，一部分操作失败的情况；
- `C-一致性`，事务完成的前后的数据是一致的，比如转账业务中的事务提交前后，总金额是一致的；
- `I-隔离性`，事务与事务之间是隔离的，也即事务A无法看到事务B的中间状态；
- `D-持久性`，事务完成后会持久化到磁盘中；

## 并发一致性问题 

多个原子操作并发运行时所产生的问题。

1. 丢失修改： 当一个线程要修改数据库中的某一个数据a时，由于还未提交到数据库进行持久化，此时另外一个线程也修改了数据a，那么在第一个线程提交后，数据库会丢失第一个线程的修改内容。

![](https://tianqingxiaozhu.oss-cn-shenzhen.aliyuncs.com/img/middleware/mysql/lose-update.png)

2. 读脏数据： 当一个线程修改了数据a但是还未提交，此时另外一个线程读取a修改后的值，但是之后第一个线程又回滚了操作，那么此时第二个线程就读取了a的脏数据。

![](https://tianqingxiaozhu.oss-cn-shenzhen.aliyuncs.com/img/middleware/mysql/read-dirty.png)

3. 不可重复读： 第一个线程先读取了数据a，但是此时另外一个线程修改了数据a，那么第一个线程又读取了一次数据a，此时第一个线程读取同一个数据的两次结果却不相同。

![](https://tianqingxiaozhu.oss-cn-shenzhen.aliyuncs.com/img/middleware/mysql/unrereadable.png)

4. 幻影读： 一个线程读取了某个范围的值，此时另外一个线程修改了这个范围内的值，那么第一个线程再次读取这个范围的值，就会得到与第一次读取内容不同的结果。

![](https://tianqingxiaozhu.oss-cn-shenzhen.aliyuncs.com/img/middleware/mysql/huanyingdu.png)

可以把上述四种并发一致性问题总结一下，划分为以下三种类型：

1. 『读-读』： 不会发生并发一致性问题；
2. 『写-写』： 会发生丢失更改的问题；
3. 『读-写』或『写-读』： 会发生读脏数据、不可重复读和幻影读的并发问题；

## 隔离级别

- 锁粒度与并发度的关系

想到控制并发一致性问题，我们自然而然想到的解决方式是加锁，但是只要加锁，就涉及到锁住的数据的多少的问题。锁住的数据多，那么锁的粒度就粗；锁住的数据少，那么锁的粒度就细。锁的粒度越粗，那么并发度就越高；锁的粒度越细，那么并发度就越低。

- 隔离级别

为什么要有隔离模式？就是因为并发度和锁粒度之间需要有一个权衡，根据不同的考量，把这种权衡划分等级，然后就有了隔离模式的说法。

并发度越高，锁住的数据就不能太多，锁粒度就要越细；并发度越低，锁住的数据会越多，锁的粒度就要越粗；

1. 读未提交（Read Uncimmitted）： 事务b能读取到事务a未提交的修改；可以理解为事务b能够看到事务a的内部操作，事务b的读操作发生在事务a已经开始，但是处于未提交的状态，也就是说事务b能读到事务a的中间状态；所以，读未提交并不能解决脏读的问题，因为可能读到事务a的中间状态；

2. 读已提交（Read Committed）： 事务b只能读取事务a已经提交的修改；可以理解为事务b无法看到事务a的内部操作，必须要等事务a完成提交之后才能看到事务a对数据的修改，事务b的读操作发生在事务a已经提交的状态，也就是说事务b只能读到事务a的结束状态；所以，读已提交解决了脏读的问题；

3. 可重复读（Repeatable Read）： 事务b多次读取同一个数据的结果是一样的；事务b的读操作发生在事务a开始之前，事务b读取的数据也是从事务a开始之前创建的快照中读取的，也就是说事务b只能读到事务a的之前状态；所以，可重复读解决了能够重复读的问题；

4. 串行化（Serialization）： 事务b和事务a串行化发生，要么事务a先执行成功，之后执行事务b；要么事务b先执行成功，之后再执行事务a；事务b的读操作必然会发生在事务a已经提交的状态，但是在事务b发生读操作之前，有可能还有其他事务也在对此数据进行操作，那事务b发生读操作之前一定是要等早于事务b开始的所有事务操作完成后才开始；所以，串行化能解决所有读写并发问题。

因此也就得出隔离级别不同，解决的读写并发一致性问题也就不同。

![](https://tianqingxiaozhu.oss-cn-shenzhen.aliyuncs.com/img/middleware/mysql/gelijibie.png)

> 大多数数据库系统的默认隔离级别都是READ COMMITTED（但MySQL不是)，InnoDB存储引擎默认隔离级别REPEATABLE READ。


<img style="border:1px red solid; display:block; margin:0 auto;" src="https://tianqingxiaozhu.oss-cn-shenzhen.aliyuncs.com/img/qrcode.jpg" alt="微信公众号" />

