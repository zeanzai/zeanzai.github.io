---
title: "Spring基本原理"
category:
  - "arch"
tag:
  - "spring"
---

## Spring 知识点提纲



## Spring为什么如此重要？

我们先来看一下，在Spring还没有出现之前，整个软件过程中所存在的“危机”。

### 危机一

例如，使用早期的Java技术来实现Web应用时，我们会这样实现：

1. 使用idea创建一个web项目
2. 创建servlet，servlet中写业务代码，组装需要数据，将数据以json格式输出
3. 在web.xml中配置servlet信息
4. 将项目部署到tomcat中

分析一下上面这种开发方式：
* 与业务相关的只有第2步中的“业务代码”部分，其余步骤均为非业务相关的技术步骤——非业务相关的技术步骤过于复杂；
* 当有很多个web模块时，每个模块都要重复1/3/4步骤——非业务相关的技术步骤过于重复；

因此，我们会发现，在Spring还没有出现之前的第一个软件危机，即： **软件过程中，非业务相关的技术步骤过于复杂与重复。**

### 危机二

再比如，我们想要使用上面的技术来完成某个业务功能时，可能会有这样的情况：

```
public class A{
    public void m1(){}
}
```

假如，我们想要在B中调用A中的m1()方法，那么我们可以这样做：
```
public class B{
    private A a; // @1
    public B(){
        this.a = new A(); //@2 此时，A的构造过程是由B控制的
    }
    public void m1(){
        this.a.m1(); //@3
    }
}

// 使用的过程是这样的：
test(){
    B b = new B();
    b.m1();
}
```

但是随着业务的发展，我们会发现上面这种方式不利于扩展，于是我们把原来在A的构造过程交出去，让使用B的使用者随意的组织A的构造过程，于是我们这样实现：
```
public class B{
    private A a;
    public B(A a){
        this.a = a;
    }
    public void m1(){
        this.a.m1(); 
    }
}

test(){
    A a = new A();  // 把A的构造过程交给了使用者test()
    B b = new B(a);
    b.m1();
}
```

但是随着业务的发展，我们又发现，上面这种方式也不利于扩展，例如如果B中依赖很多的类似于A的对象，比如需要依赖于C、D、E、F或者更多对象，那么我们首先要调整B的构造方法，其次还要调整test()的使用过程，于是代码又变成这样：
```
public class B{
    private A a;
    private C c;
    
    private D d;
    private E e;
    public B(A a, C c, D d, E e){
        this.a = a;
        this.c = c;
        this.d = d;
        this.e = e;
    }
    public void m1(){
        this.a.m1(); 
    }
}

test(){
    // A/C/D/E 的构造过程仍然在使用者test()手里
    A a = new A(); 
    C c = new C();
    D d = new D();
    E e = new E();
    B b = new B(a, c, d, e);
    b.m1();
}
```

因此，我们会发现，在Spring还没有出现之前的第二个软件危机，即： **编程语言特性决定的bean的构造过程的灵活特性，同时也导致bean的管理与维护不够标准和规范。**

### 总结

传统的软件工程中存在“危机”：
- **软件过程中，非业务相关的技术步骤过于复杂与重复。**
- **编程语言特性决定的bean的构造过程的灵活特性，同时也导致bean的管理与维护不够标准和规范。**

而Spring的出现，彻底解决了上面的这些问题。

## Spring的核心原理

核心原理分成几个步骤：

1. 把Bean简单化，简单到只完成具体的业务功能，简单的实现思路就是把通用功能和具体的业务功能进行剥离，然后形成一个个独立的Bean。结果就涉及到另外一个问题： 如何管理这些单个独立的Bean，答案是： 构造一个管理所有Bean的组件并实现控制反转（IoC），即实现一个组件，让这个组件具有管理所有Bean的功能，并且这个组件能够控制Bean的生命周期（即Bean的构造和销毁，以及中间的使用过程）。
2. 完成上面的步骤后，还涉及到另外两个问题：
   1. 如何把剥离出来的通用功能（如日志管理功能、安全控制功能）重新组织回Bean；
   2. 如何组织和管理不同Bean复用；
  解决上面两个问题的思路是： 依赖注入（DI），即把这些通用的功能使用某种技术注入到Bean中，具体的实现技术是： 动态代理，思路是在运行期动态生成新的Java代码，让Java代码重新具有完成所有的功能。

> 动态代理 vs 静态代理： 










---
## 产生的背景

早期的软件设计中，Java类的管理很混乱，比如说，我们创建了一个Student类，类里面包括了一些属性和一些简单方法，于是我们在使用的过程中，就是简单的去new一个对象出来。

但是随着软件的发展，我们对Student类的要求越来越多，比如：

1. 在类生成的时候记录一下所有属性的值；
2. 在类销毁的时候给Teacher类发送一个通知；
3. 在创建这个类的实例对象时，还要提前创建一个Clazz类，表示这个学生所属的班级信息；
4. ……

我们就会发现，这个Student类会越来越复杂。这就使得我们对Java类的管理失去了控制。于是人们就想有没有一种方法来解决上面的这些问题。于是Spring就产生了。

## Spring产生的背景

早期的面向对象的软件过程中，类的管理完全是需要程序员自定义去实现的，随着系统的迭代，类就会膨胀，也会变得越来越复杂，最终导致软件系统失去控制。

计算机大神们研发了一款软件，可以管理程序员自定义的各种类，这款软件产品就是Spring。

这款软件产品完成了本来需要程序员完成的功能，例如：

1. 单个Bean的生命周期管理；
2. 多个Bean的组织和装配，说白了就是能够处理多个Bean之间的相互依赖关系，何时构造、何时组织和装配；

> 组织和装配： 比如 Student 类中有一个 Class 类，表明学生所属的班级信息，我们自定义实现时，会new一个class对象，然后把这个class对象传给student作为student的构造参数。有了Spring之后就只需要写Student类和Class类，这二者之间的组织过程和装配过程就交给Spring来处理了。





## Bean 的注册 

盛放Bean的容器已经创建好了，下一个步骤就是把Bean放到容器中，把Bean放到容器中的过程就是Bean的注册。




### Bean的分类

实现容器的各种Java代码本身也是Bean，因此Spring需要管理这些Bean。此外，还有针对具体业务编写的Java代码，这些也是JavaBean，因此Spring也需要管理这些Bean。

管理Spring框架中自身的Bean的过程是随着Spring的启动的完成而完成的，这个过程，我们在Spring容器的启动过程中来讲解。

针对具体业务代码编写的JavaBean，我们就需要了解Spring的Bean的装配方式。即Spring是如何把Bean注入到容器中，并完成组织和管理Bean的功能的。

如果往底层看其原理，就应该是如何构造一个管理和组织Bean的容器，以及如何构建管理和组织Bean的规则，以及如何扩展管理和组织的规则。

有了Bean工厂以后，我们就可以自由自在的使用各种JavaBean了。我们在Spring项目中使用Bean的方式大概有两种，一种是直接使用Bean，另外一种是把Bean A注入到另外一个Bean B里面，然后使用Bean B。也就是直接使用和间接使用。

使用间接方式注册到Bean工厂的过程称为装配。（有点像装配车间的概念，把多个模块封装然后分配到各个位置形成统一的整体，然后使用这个整体）。


