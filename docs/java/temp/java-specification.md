---
"title": "java中的一些概念"
category:
  - ""
tag:
  - ""
---


## EJB

### 互联网产品的服务模式的发展与迭代

- singleton应用模式： 把完成企业各项任务的互联网产品进行封装，然后把封装后的这个互联网产品放到客户端运行，这样的互联网产品的构建模式就是狭义上的“单体应用”。【现在广义上的“单体应用”是指，各个功能模块没有拆分，还是聚合在一起的应用】
- CS模式： 后来人们发现上面的单体应用模式会产生一些问题，比如上面的这种产品多是一锤子买卖，不会有后续更新的可能性。于是人们就想，把一些核心功能放到某一台主机上，让这台主机来完成核心功能，其余非核心功能就放到客户端。这样就产生了cs模式的应用。
- BS模式： 后来人们又发现cs模式也不太行，因为互联网产品更新迭代过程太快了，可能连客户端也需要经常来更新和维护了。于是人们就又基于网络开发出BS模式的互联网产品。就是把原来直接安装到客户端主机上的客户端软件，直接简化，简化成只有一个域名的互联网入口，所有的企业级服务都通过网络来提供。



CS模式的实现技术： RPC VS RMI

- RPC（Remote Procedure Call）： 说白了，就是本地计算机调用远程计算机上的一个函数。在 Java 之前的大多数编程语言，如，Fortran、C、COBOL 等等，都是过程性的语言，而不是面向对象的。所以，这些编程语言非常自然地用过程表示工作。也就是 RPC 并不是Java的专有名词。但是这种开发模式，需要程序员关注网络部分，也就是说除了要编写远程计算机上的任务函数外，在本地计算机上调用远程计算机上的任务函数时，还要关注如何使用网络问题（如网络传输的协议、数据传输的格式、网络的异常处理等）。
- RMI（Remote Method Invocation）： 由于 RPC 过程需要额外处理网络的问题，在发展过程中人们发现网络问题是通用的，人们可以把网络问题的处理过程抽象出来，让程序员只关注实际的业务处理部分。于是，这种实现方式就变成了本地主机直接调用远程主机的方法。于是 RMI 出现。


EJB（Enterprise Java Bean）： EJB 的官方解释是“**商务软件的核心部分是它的业务逻辑。业务逻辑抽象了整个商务过程的流程，并使用计算机语言将他们实现。**”变成大白话就是，“**把你编写的软件中那些须要执行制定的任务的类，不放到client软件上了，而是给他打成包放到一个server上了**”。通过RMI 技术，J2EE 将EJB 组件创建为远程对象，EJB 尽管用了RMI 技术，可是却仅仅需要定义远程接口而无需生成他们的实现类，这样就将RMI 技术中的一些细节问题屏蔽了。但无论怎么说，EJB 的基础仍然是RMI，所以，假设你想了解EJB 的原理，仅仅要把RMI的原理搞清楚即可了。

- 【[EJB究竟是什么，真的那么神奇吗？？](https://cloud.tencent.com/developer/article/2048526)】
- 【[EJB到底是什么，真的那么神秘吗？](https://blog.51cto.com/u_3664660/3214556)】



## Java中的Bean、POJO、DTO、VO、DO、DAO

### Java语言的设计缺陷

> Java语言欠缺属性、事件、多重继承功能。所以，如果要在Java程序中实现一些面向对象编程的常见需求，只能手写大量胶水代码。Java Bean正是编写这套胶水代码的惯用模式或约定。这些约定包括getXxx、setXxx、isXxx、addXxxListener、XxxEvent等。遵守上述约定的类可以用于若干工具或库。 ——来源：[杨博](https://www.zhihu.com/question/19773379/answer/31625054)

### POJO vs JavaBean 

POJO 的全称是 Plain Old Java Object, 简单又老的 Java 对象。那些没有继承任何类、也没有实现任何接口，更没有被其它框架侵入的java对象。2005年11月时，“POJO”主要用来指代那些没用遵从特定的Java对象模型，约定或框架（如EJB）的Java对象。

1. 比如有这样一个场景：我们要设计一个List类并且需要保存这个List的大小。那么，我们的实现方式可能是这样的：我们直接把size直接设置成pulic的形式，然后通过“对象.size”的方式进行访问，并通过“对象.size”的方式进行设值。 

但是这种方式会有两个问题：
    - 那就是每一个new出来的对象都有一个size变量，如果很多list对象，那就需要有很多的内存空间来保存这个size变量；
    - 随着业务的发展，list可能需要增加多个属性，比如name等，也就是说每一个list对象所占用的内存空间可能就不固定，会根据属性的增多而变大；
  
于是人们就使用另外一种方式来实现上面的这个场景：把属性设置成private的形式，然后通过添加对属性的get、set方法，实现对这个属性的控制。这种设计方式就解决了上面可能会遇到的两个问题。

于是人们就从这件事情上得到一个结论： Java语言的设计是有缺陷的。并由此，人们又得出一个结论： 人们在使用Java时需要有一些规范或规约。于是，JavaBean登场。

人们把满足下面特征的Java对象统称为JavaBean：

- 提供默认的构造方法；
- 所有属性的访问范围为private；
- 提供针对属性的get、set方法；
- 实现序列化接口；

简而言之，当一个POJO可序列化，有一个无参的构造函数，使用getter和setter方法来访问属性时，他就是一个JavaBean。（没毛病！）

EJB 2.x 的 Entity Beans 比较重量，需要实现 javax.ejb 的一些接口。而 POJO 就比较轻量，就是一个 Java 对象，不需要实现任何的接口。

有了这个概念（惯例），Spring, Hibernate 这些框架交流、实现起来，都大量使用 Bean 这个概念。比如“注入一个 Bean“，“声明一个 Bean”，你就知道这里的这个 Bean 必须要有无参数的构造函数，必须要有 setter/getter 等等。这些框架在使用的时候，会采用初始化出来 Bean 然后 setXX() 这种方式，构造出来最终的 Bean.



## TODO

总结一下：
1. jdk只完成了基于Java语言实现简单的功能，如科学计算等；
2. 商业软件中需要很多的特性，于是Java语言开发出适合企业使用的功能，实现这些功能的Java语言称为J2EE；
3. 基于J2EE实现企业级功能的实现方式有一种事实上的规范，这种规范就是EJB，它最大的特点就是把核心的商业功能拆分成server端和非核心的商业功能拆分成client端，然后client端和server端通过RMI方式链接，并为了实现算力最大化，在server端实现了服务集群的过程。即EJB最大特点是：cs模式+RMI+服务集群。所以EJB逐渐成为J2EE的一部分。
4. 在EJB中，把具有某种可重复使用功能的Java组件叫做Bean。Java Bean是基于Java的组件模型，由属性、方法和事件3部分组成。在该模型中，JavaBean可以被修改或与其他组件结合以生成新组件或完整的程序。它是一种Java类，通过封装成为具有某种功能或者处理某个业务的对象。
5. 除了这种bean以外，还有一种Java类，这种类不继承任何类、也不实现任何接口、更不会使用任何框架，这种类就称为POJO。
6. 后来EJB中的Bean发展成为一个软件开发标准，人们又总结发展出另外一个概念： JavaBean，即凡是具有默认构造函数、属性私有化、提供针对属性的get和set方法并实现序列化接口的POJO统称为JavaBean。
7. PO、VO、DTO、DO、BO等是后续发展过程中不断添加的一些概念。


RPC vs RMI 

- RPC（Remote Procedure Call）： 说白了，就是本地计算机调用远程计算机上的一个过程。在 Java 之前的大多数编程语言，如，Fortran、C、COBOL 等等，都是过程性的语言，而不是面向对象的。所以，这些编程语言非常自然地用过程表示工作。也就是 RPC 并不是Java的专有名词。但是这种开发模式，需要程序员关注网络部分，也就是说除了要编写远程计算机上的任务函数外，在本地计算机上调用远程计算机上的任务函数时，还要关注如何使用网络问题（如网络传输的协议、数据传输的格式、网络的异常处理等）。
- RMI（Remote Method Invocation）： 由于 RPC 过程需要额外处理网络的问题，在发展过程中人们发现网络问题是通用的，人们可以把网络问题的处理过程抽象出来，让程序员只关注实际的业务处理部分。于是，这种实现方式就变成了本地主机直接调用远程主机的方法。于是 RMI 出现。

可以理解为： RMI + 网络处理 = RPC。

---
<br />
<br />
<br />
<img style="border:1px red solid; display:block; margin:0 auto;" src="https://tianqingxiaozhu.oss-cn-shenzhen.aliyuncs.com/img/qrcode.jpg" alt="微信公众号" />


