---
title: "04-GC算法和种类"
category:
  - "core"
tag:
  - "jvm"
---


# GC的概念

	垃圾回收，主要用来解决由程序引起的内存泄露等问题，GC的对象是堆空间和永久区

# GC的算法

	- 引用计数法
		老牌垃圾回收算法，通过引用计算来回收垃圾，使用者：COM、ActionScript3、Python
		问题：引用和去引用都伴随着加法和减法，影响性能；很难处理循环引用的垃圾对象

		【在Java中并没有使用这种算法】

	- 标记清除【老年代回收算法】
		分为标记阶段和清除阶段。从根节点开始，标记所有可达的对象，未被标记的对象就是未被引用的垃圾对象，然后是清除阶段，清除所有未被标记的对象。

	- 标记压缩【老年代回收算法】
		适合存活对象比较多的场合，如老年代。也是从根节点开始，对所有可达对象做一次标记，然后将标记对象压缩到内存的一端，之后，清理边界外的所有空间


	- 复制算法【新生代回收算法】
		比较高效的回收方法，不适合存活对象较多的场合，如老年代。将内存区域分为两块，每次只使用其中的一块，在垃圾回收时，将正在使用的内存中的存活对象复制到未使用的内存中，之后，清除正在使用的内存块中的所有对象，交换两个内存的角色，完成回收。
		最大的问题就是空间浪费、整合标记清除的思想
		三个存储空间和一个担保空间【复制算法+标记清理的算法】

		-XX:+PrintGCDetails的输出中的eden和from、to等就是标记复制算法的三块区域

		分代思想：
		短命对象为新生代，长命对象为老年代

		少量对象存活，使用复制算法；
		大量对象存活，使用标记清理或标记压缩算法等；

	【总结】
	所有的算法，都需要识别一个对象是否为垃圾对象，因此需要给出什么是垃圾对象的定义。即什么是可触及性？

# 可触及性
	- 可触及的
		从根节点可以触及到这个对象
	- 可复活的
		暂时没有被触及，但是后期又被触及的对象
		可能会在finalize()中可能复活对象
	- 不可触及的
		在finalize()后，可能进入不可触及状态，可以回收
		finalize()只能被执行一次，避免使用该方法，优先级太低，不确定何时被调用，可以使用try catch finally等来代替

	- 根
		栈中引用的对象，即线程栈中引用的对象
		方法区中静态成员或常量引用的对象（即全局对象）
		jni方法栈中引用的对象

# stop-the-world
	java中一种全局暂停的现象，所有java代码停止，native代码可以执行，但是不能和jvm交互。可以理解为整个jvm处于挂起状态。
	多半是由于GC引起
		dump线程时
		死锁检查
		堆dump时

	为什么gc会产生全局停顿？
		类比于聚会时打扫房间，聚会时会很乱，又会有新的垃圾产生，房间永远打扫不干净，只有让大家停止活动了，才能将房间打扫干净。
		GC线程启动时，所有的应用线程都会停止。
	会有什么危害？
		长时间服务停止，没有响应。
		遇到ha系统，可能会引起主备切换，严重危害生产系统
<img style="border:1px red solid; display:block; margin:0 auto;" :src="$withBase('/qrcode.jpg')" alt="微信公众号" />
