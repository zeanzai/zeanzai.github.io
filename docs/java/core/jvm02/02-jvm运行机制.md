---
title: "02-jvm运行机制"
category:
  - "core"
tag:
  - "jvm"
---


# jvm的启动流程
```
装载配置-根据配置找jvm.dll文件-初始化jvm获取到JNIEnv接口-找到main方法，并运行
```

# jvm的基本结构
	主要关注的时内存空间的分配和回收
	PC寄存器
		- 一个线程独占一个pc寄存器
		- 线程创建时创建
		- 存放的是下一条要执行的指令的地址
		- 执行本地方法时，PC寄存器存放的内容为undefined
	方法区
		- 保存类的元信息（常量池、字段、方法信息、方法字节码等）
		- 通常和永久区（perm）关联在一起
		- 跟jdk的版本有关
	Java堆
		- 和程序开发最密切相关的区域
		- 应用系统对象基本上都是保存在java堆上面
		- 所有线程共享Java堆
		- 对分代GC来说，堆也是分代的
		- 不同的GC算法，对应的也是不同的堆
	Java栈
		- 线程私有
		- 栈由一系列帧组成的
		- 帧保存一个方法的局部变量、操作数栈、常量池指针
		- 每一个方法调用都会创建一个帧，并压栈（栈：先进后出）
		- 局部变量表（包括参数和局部变量）
		- 函数调用组成栈帧
		- 操作数栈：java中没有寄存器的概念，所有的参数传递都使用操作数栈
		- 栈上分配：
			一般是小对象（几十个bytes），大对象或逃逸对象是没有办法在栈上分配的，在没有逃逸的情况下是可以直接分配到栈上的，这样做的好处是可以自动回收，减轻gc压力；
		- 逃逸分析：
			逃逸分析的基本行为就是分析对象动态作用域，当一个对象在方法中被定义后，可能会被外部方法所引用，比如方法调用，也有可能被其他线程访问，比如类变量，这两种情况分别叫做对象的方法逃逸和线程逃逸
	本地方法栈

	栈、堆、方法区交互
		可以根据具体的程序来分析，主要描述程序代码的存储位置以及运行流程


# jvm的内存模型
	- 每一个线程都有一个工作内存和主内存
	- 工作内存存放主存中变量的值的拷贝

	- 可见性
		一个线程修改了变量，其他线程可以立即知道

		产生变量不可见的原因：
			每一个线程都有自己的主存区域和线程工作内存区域，线程在使用变量时，会先把存放到主存中的变量load到线程工作内存区域，这就导致了一个线程修改变量时，另外一个线程没办法同时共享该变量，导致了变量的暂时不可见性。

		保持变量可见性的方法：
			- volatile 关键字
			- synchronized （unlock之前，写变量值到主存中）
			- final（一旦初始化之后，其他线程就可见）

	- 有序性
		操作指令的顺序在本线程内时有序的，但是在本线程外是无序的（因为发生了指令重排或主内存与工作内存同步延时）。

		指令重排-容易破坏线程间的指令有序性
		保证线程之间的指令有序性的方法：使用synchronized关键字，使线程互斥运行，人为保证指令的有序性。

		指令重排的原则：
			- 线程内保证语义的串行性
			- volatile规则： volatile变量的写，先发生于读
			- 锁规则：解锁必然要发生在另外线程的加锁前
			- 传递性： a先于b，b先于c，那a必然先于c
			- 线程的start方法先于其他所有的动作
			- 线程所有的操作先于线程的终结
			- 线程的中断先于中断后要执行的代码
			- 构造方法先于finalize（）方法


# 编译运行和解释运行的区别
	- 这是字节码运行的两种方式：
	- 解释运行
		- 读一句执行一句
	- 编译运行
		- 先将字节码编译成机器码，运行时直接执行机器码，只在运行时进行编译
		编译后的性能比解释运行的性能有数量级的提升
<img style="border:1px red solid; display:block; margin:0 auto;" :src="$withBase('/qrcode.jpg')" alt="微信公众号" />
