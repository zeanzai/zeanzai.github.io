---
title: "01.类的编译、加载及运行"
category:
  - "core"
tag:
  - "jvm"
---


## 类的编译、加载、运行

程序员编写的java文件要想被java虚拟机运行，至少需要经过`编译`、`加载`、`运行`等三个阶段。编译阶段涉及到的理论知识较多，编译的阶段也因不同的虚拟机实现而各有差别。此外，编译阶段因与虚拟机的具体实现密切相关，而应用程序多是由程序员开发机编译之后发布使用，所以编译阶段的内容多不为程序员所重视，在面试阶段也很少被提及。

对于加载阶段，在部分java项目中需要由程序员自定义实现，程序员需要熟悉具体的加载过程才能很好的开发自定义的加载器，在面试阶段，`加载也是重点考查`内容。

运行阶段就相对简单了，面试过程也不怎么考查。

### 编译

- 编译期概述
  - 这是一个不确定的过程，可能指把java文件转变成class文件的过程（完成这类过程的编译器被称为前端编译期），也可能是把字节码转变成机器码的过程（完成这类过程的编译器被称为运行期编译器），还可能是直接把java文件转变成机器码的过程（完成这类过程的编译器被称为静态提前编译器）
  - javac就是属于第一种过程中的编译期，即javac把java文件转变称class文件
- 编译概念：什么是编译
  - 将一种语言规范转化成另外一种语言规范，即将`便于人理解的语言规范`转化成`机器容易理解的语言规范`的过程就是编译
- javac是个什么鬼？
  - sun公司的一个编辑器，属于`前端编译期`的一种
  - 由java语言编写完成
  - 对java语言编码过程进行优化，但对编译后的代码运行效率没有任何优化
- javac的编译过程
  - 解析与填充符号表过程
  - 插入式注解处理器的注解处理过程
  - 语义分析与字节码生成过程
![img](https://tianqingxiaozhu.oss-cn-shenzhen.aliyuncs.com/img/jvm/jvm-compile-process-src-model.png)
![img](https://tianqingxiaozhu.oss-cn-shenzhen.aliyuncs.com/img/jvm/jvm-compile-process.png)
- java语法糖
  - 泛型与类型擦除
  - 自动装箱、拆箱与遍历循环
  - 条件编译
- 解释器与编译器
  - 交互
![img](https://tianqingxiaozhu.oss-cn-shenzhen.aliyuncs.com/img/jvm/hotspot-compile-interperter-alternation.png)
  - javac可以看作是解释器
  - C1编译器
    - 是一个简单快速的三段式编译器，主要关注点在于局部性的优化，而放弃了许多耗时较长的全局优化
    - 在字节码上进行一些基础优化，方法内联、常量传播
    - 将字节码构造成高级中间表示HIR（静态单分配），再次进行一些优化，空值检查消除、范围检查消除等
    - 将HIR转换成LIR，寄存器分配、窥孔优化、机器码生成
![img](https://tianqingxiaozhu.oss-cn-shenzhen.aliyuncs.com/img/jvm/hotspot-c1.png)
  - C2编译器
    - C2会执行所有的经典优化动作，如无用代码删除、循环展开、循环表达式外提、消除公共子表达式、常量传播、基本快重排序等
  - 热点代码检测
- JIT即时编译器

> 延伸： class文件的内容

### 加载

- 加载过程
  - 通过全限定命名获取字节码文件
  - 将字节码文件中的类元数据信息加载到运行时数据区的方法区
  - 在运行时数据区的堆中创建一个java.lang.Class类的对象
- 运行时数据区的分配
  - 方法区上封装类的元数据信息
  - 堆区上分配class对象
- 加载时机：什么时候开始加载？
  - 预加载：并不一定首次使用才进行加载，jvm会在预判就进行加载
  - 时机：
    - `使用new关键字实例化对象`、`读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）`以及`调用一个类的静态方法`时
    - 使用java.lang.reflect包的方法对类进行反射调用时
    - 初始化一个类但发现其父类还没有进行初始化时
    - 启动jvm时先加载包含main()方法的启动类
    - 当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化
  - 报错：如果未加载，则在使用时会报错（LinkageError错误）；如果一直没有被使用，即便未加载也不会报错
- 加载途径：可以从哪些地方加载类到jvm中？
  - 本地
  - 网络
  - 数据库
  - jar、zip、war...
  - 动态编译
- 加载方式：可以通过哪些方式把类加载到jvm中？
  - 命令行启动应用时候由JVM初始化加载
  - 通过Class.forName()方法动态加载
  - 通过ClassLoader.loadClass()方法动态加载
- 类加载器
  - 启动类加载器：Bootstrap ClassLoader
    - 使用C++实现（仅限于Hotspot）
    - 是jvm的一部分
    - 无法被java程序直接使用
    - 负责加载的内容
      - jre/lib 下的类库
      - 被-Xbootclasspath参数指定的路径中的且能被虚拟机识别的类库
    - 负责加载 jre/lib 被-Xbootclasspath参数指定的路径中的
  - 扩展类加载器：Extension ClassLoader
    - 由sun.misc.Launcher$ExtClassLoader实现
    - 开发者可以直接使用
    - 负责加载的内容
      - jre/lib/ext目录下的类库
      - 由java.ext.dirs系统变量指定的路径中的所有类库（如javax.开头的类）
  - 应用程序类加载器：Application ClassLoader
    - 由sun.misc.Launcher$AppClassLoader来实现
    - 开发者可以直接使用
    - 负责加载用户类路径（ClassPath）所指定的类
    - 如果未自定义加载器，那它就是默认加载器
  - 自定义类加载器：
    - 定制化
- 加载原则：加载时有哪些原则？
  - 全盘负责：加载器在加载类时，连同类的依赖和引用也一并加载
  - 双亲委派：使用某一个加载器加载时，会委托父类加载器先进行加载
    - 优点：防止内存中出现多份同样的字节码; 提高安全性
    - 有哪些破坏双亲委派模型的案例？
  - 缓存机制：加载过的Class都会被缓存


### 执行

JVM是基于栈的体系结构来执行class字节码的。线程创建后，都会产生程序计数器（PC）和栈（Stack），程序计数器存放下一条要执行的指令在方法内的偏移量，栈中存放一个个栈帧，每个栈帧对应着每个方法的每次调用，而栈帧又是有局部变量区和操作数栈两部分组成，局部变量区用于存放方法中的局部变量和参数，操作数栈中用于存放方法执行过程中产生的中间结果

![img](https://tianqingxiaozhu.oss-cn-shenzhen.aliyuncs.com/img/jvm/run-process.png)

- 栈帧结构
![img](https://tianqingxiaozhu.oss-cn-shenzhen.aliyuncs.com/img/jvm/stack-frame.png)


## 对象的生命周期

- 加载：第一阶段
- 链接：第二阶段，分为三个步骤
  - 验证：文件格式、元数据、字节码、符号引用验证
  - 准备：为类的静态变量（也称为类变量）分配内存，并将其初始化为默认值
  - 解析：把类中的符号引用转换为直接引用
- 初始化：第三阶段，为类的静态变量赋予正确的初始值
  - 类初始化的时机：只有当对类的主动使用的时候才会导致类的初始化
    - 创建类的实例，也就是new的方式
    - 访问某个类或接口的静态变量，或者对该静态变量赋值
    - 调用类的静态方法
    - 反射（如Class.forName(“com.shengsiyuan.Test”)）
    - 初始化某个类的子类，则其父类也会被初始化
    - Java虚拟机启动时被标明为启动类的类（Java Test），直接使用java.exe命令来运行某个主类
- 使用：new出对象程序中使用
- 卸载：执行垃圾回收
  - 时机：什么时候卸载java类？
    - 执行了System.exit()方法
    - 程序正常执行结束
    - 程序在执行过程中遇到了异常或错误而异常终止
    - 由于操作系统出现错误而导致Java虚拟机进程终止

## 一个示例

### 简单概述

Java整个编译以及运行的过程相当繁琐，本文通过一个简单的程序来简单的说明整个流程。如下图，Java程序从源文件创建到程序运行要经过两大步骤：

1. 源文件由编译器编译成字节码（ByteCode）
2. 字节码由java虚拟机解释运行

![img](https://tianqingxiaozhu.oss-cn-shenzhen.aliyuncs.com/img/jvm/jvm-compile-and-run.png)

因为java程序既要编译同时也要经过JVM的解释运行，所以说Java被称为半解释语言（ "semi-interpreted" language）。

### 详细过程

下面通过以下这个java程序，来说明java程序从编译到最后运行的整个流程。代码如下：

```java
//MainApp.java
public class MainApp {
    public static void main(String[] args) {
        Animal animal = new Animal("Puppy");
        animal.printName();
    }
}
//Animal.java
public class Animal {
    public String name;
    public Animal(String name) {
        this.name = name;
    }
    public void printName() {
        System.out.println("Animal ["+name+"]");
    }
}
```


#### 第一步：编译过程

创建完源文件之后，程序会先被编译为.class文件。Java编译一个类时，如果这个类所依赖的类还没有被编译，编译器就会先编译这个被依赖的类，然后引用，否则直接引用，这个有点象make。如果java编译器在指定目录下找不到该类所其依赖的类的.class文件或者.java源文件的话，编译器话报“cant find symbol”的错误。

> 编译后的字节码文件格式主要分为两部分：常量池和方法字节码。常量池记录的是代码出现过的所有token(类名，成员变量名等等)以及符号引用（方法引用，成员变量引用等等）；方法字节码放的是类中各个方法的字节码。
>
>
> 下面是MainApp.class通过反汇编的结果，我们可以清楚看到.class文件的结构：

![常量池](https://tianqingxiaozhu.oss-cn-shenzhen.aliyuncs.com/img/jvm/constant-pool.png)

![类方法字节码](https://tianqingxiaozhu.oss-cn-shenzhen.aliyuncs.com/img/jvm/mathod-byte-code.png)

#### 第二步：运行过程

java类运行的过程大概可分为两个过程：1、类的加载  2、类的执行。需要说明的是：JVM主要在程序第一次主动使用类的时候，才会去加载该类。也就是说，JVM并不是在一开始就把一个程序就所有的类都加载到内存中，而是到不得不用的时候才把它加载进来，而且只加载一次。

#### 详细过程描述

下面是程序运行的详细步骤：

1. 在编译好java程序得到MainApp.class文件后，在命令行上敲java AppMain。系统就会启动一个jvm进程，jvm进程从classpath路径中找到一个名为AppMain.class的二进制文件，将MainApp的类信息加载到运行时数据区的方法区内，这个过程叫做MainApp类的加载。
2. 然后JVM找到AppMain的主函数入口，开始执行main函数。
3. main函数的第一条命令是Animal  animal = new Animal("Puppy");就是让JVM创建一个Animal对象，但是这时候方法区中没有Animal类的信息，所以JVM马上加载Animal类，把Animal类的类型信息放到方法区中。
4. 加载完Animal类之后，Java虚拟机做的第一件事情就是在堆区中为一个新的Animal实例分配内存, 然后调用构造函数初始化Animal实例，这个Animal实例持有着指向方法区的Animal类的类型信息（其中包含有方法表，java动态绑定的底层实现）的引用。
5. 当使用animal.printName()的时候，JVM根据animal引用找到Animal对象，然后根据Animal对象持有的引用定位到方法区中Animal类的类型信息的方法表，获得printName()函数的字节码的地址。
6. 开始运行printName()函数。

![java程序运行过程](https://tianqingxiaozhu.oss-cn-shenzhen.aliyuncs.com/img/jvm/java-file-run-proceed.png)



```
特别说明： java类中所有public和protected的实例方法都采用动态绑定机制，所有私有方法、静态方法、构造器及初始化方法<clinit>都是采用静态绑定机制，而使用动态绑定机制的时候会用到方法表，静态绑定时并不会用到。

本文只是讲述java程序运行的大概过程，所以并没有细加区分。本文的所述的流程非常粗糙，想深入了解的读者请查阅其他资料。存在谬误的地方，请多指正。
```


---

<img style="border:1px red solid; display:block; margin:0 auto;" src="https://tianqingxiaozhu.oss-cn-shenzhen.aliyuncs.com/img/qrcode.jpg" alt="微信公众号" />
