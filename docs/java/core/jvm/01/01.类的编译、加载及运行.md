---
title: "01.类的编译、加载及运行"
category:
  - "core"
tag:
  - "jvm"
---



## Java中运行代码的方式


![20230630150922](https://tianqingxiaozhu.oss-cn-shenzhen.aliyuncs.com/blog20230630150922.png)


Java中运行代码的方式分为两种，`解释运行` 和 `编译运行`。 

`解释运行`是对字节码文件逐行解释执行，换言之，就是依次读取.class文件的每一行，然后把读取到的字节码“翻译”成机器语言进行执行，这种方式​效率低下。JS、JSP、ASP等语言都是解释型编程语言。

`编译运行`则是将一种语言规范转化成另外一种语言规范，即将`便于人理解的语言规范`转化成`机器容易理解的语言规范`的过程就是编译。


### 编译器

编译运行一般情况下会有专门的编译器来完成编译工作，Java中根据编译器的作用把编译器分为三类：

- 前端编译器，主要作用是把.java文件编译成.class文件，如javac、ECJ等；
- 后端编译器（JIT即时编译器），主要作用是把字节码文件转变成可执行的机器码，主要有两种C1和C2编译器，C1的启动时间比C2启动时间短，系统稳定后，C2执行效率比C1高；
- 静态提前编译器（AOT编译器），​直接把.java文件转变成可执行的机器码，​包括GCJ等，还处于实验阶段；

::: tip 
HotSpotJVM是两种方式并存的。运行过程​原理大概是这样的：等待所有的代码编译完成再进行运行是不值得的，项目启动前期就要使用解释器解释执行一些代码，同时也会针对执行到的热点代码进行探测，对热点代码再进行编译执行，相当于对二者进行取长补短。

使用什么技术探测热点代码？
- ​使用`方法调用计数器`​统计方法的调用次数，配置参数： ​-XX:CompileThreshold
- 使用`​回边计数器`​统计循环体的执行次数

对热点代码的优化手段？
- ​栈上分配
- 同步消除
- ​标量替换
:::

---



## 类的加载

![类的加载](https://tianqingxiaozhu.oss-cn-shenzhen.aliyuncs.com/blog类的加载.jpg)

- 加载过程
  - 通过全限定命名获取字节码文件
  - 将字节码文件中的类元数据信息加载到运行时数据区的方法区
  - 在运行时数据区的堆中创建一个java.lang.Class类的对象
- 运行时数据区的分配
  - 方法区上封装类的元数据信息
  - 堆区上分配class对象
- 加载时机：什么时候开始加载？
  - 预加载：并不一定首次使用才进行加载，jvm会在预判就进行加载
  - 时机：
    - `使用new关键字实例化对象`、`读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）`以及`调用一个类的静态方法`时
    - 使用java.lang.reflect包的方法对类进行反射调用时
    - 初始化一个类但发现其父类还没有进行初始化时
    - 启动jvm时先加载包含main()方法的启动类
    - 当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化
  - 报错：如果未加载，则在使用时会报错（LinkageError错误）；如果一直没有被使用，即便未加载也不会报错
- 加载途径：可以从哪些地方加载类到jvm中？
  - 本地
  - 网络
  - 数据库
  - jar、zip、war...
  - 动态编译
- 加载方式：可以通过哪些方式把类加载到jvm中？
  - 命令行启动应用时候由JVM初始化加载
  - 通过Class.forName()方法动态加载
  - 通过ClassLoader.loadClass()方法动态加载
- 类加载器
  - 启动类加载器：Bootstrap ClassLoader
    - 使用C++实现（仅限于Hotspot）
    - 是jvm的一部分
    - 无法被java程序直接使用
    - 负责加载的内容
      - jre/lib 下的类库
      - 被-Xbootclasspath参数指定的路径中的且能被虚拟机识别的类库
    - 负责加载 jre/lib 被-Xbootclasspath参数指定的路径中的
  - 扩展类加载器：Extension ClassLoader
    - 由sun.misc.Launcher$ExtClassLoader实现
    - 开发者可以直接使用
    - 负责加载的内容
      - jre/lib/ext目录下的类库
      - 由java.ext.dirs系统变量指定的路径中的所有类库（如javax.开头的类）
  - 应用程序类加载器：Application ClassLoader
    - 由sun.misc.Launcher$AppClassLoader来实现
    - 开发者可以直接使用
    - 负责加载用户类路径（ClassPath）所指定的类
    - 如果未自定义加载器，那它就是默认加载器
  - 自定义类加载器：
    - 定制化
- 加载原则：加载时有哪些原则？
  - 全盘负责：加载器在加载类时，连同类的依赖和引用也一并加载
  - 双亲委派：使用某一个加载器加载时，会委托父类加载器先进行加载
    - 优点：防止内存中出现多份同样的字节码; 提高安全性
    - 有哪些破坏双亲委派模型的案例？
  - 缓存机制：加载过的Class都会被缓存


## 执行

JVM是基于栈的体系结构来执行class字节码的。线程创建后，都会产生程序计数器（PC）和栈（Stack），程序计数器存放下一条要执行的指令在方法内的偏移量，栈中存放一个个栈帧，每个栈帧对应着每个方法的每次调用，而栈帧又是有局部变量区和操作数栈两部分组成，局部变量区用于存放方法中的局部变量和参数，操作数栈中用于存放方法执行过程中产生的中间结果

![img](https://tianqingxiaozhu.oss-cn-shenzhen.aliyuncs.com/img/jvm/run-process.png)

- 栈帧结构
![img](https://tianqingxiaozhu.oss-cn-shenzhen.aliyuncs.com/img/jvm/stack-frame.png)


## 对象的生命周期

- 加载：第一阶段
- 链接：第二阶段，分为三个步骤
  - 验证：文件格式、元数据、字节码、符号引用验证
  - 准备：为类的静态变量（也称为类变量）分配内存，并将其初始化为默认值
  - 解析：把类中的符号引用转换为直接引用
- 初始化：第三阶段，为类的静态变量赋予正确的初始值
  - 类初始化的时机：只有当对类的主动使用的时候才会导致类的初始化
    - 创建类的实例，也就是new的方式
    - 访问某个类或接口的静态变量，或者对该静态变量赋值
    - 调用类的静态方法
    - 反射（如Class.forName(“com.shengsiyuan.Test”)）
    - 初始化某个类的子类，则其父类也会被初始化
    - Java虚拟机启动时被标明为启动类的类（Java Test），直接使用java.exe命令来运行某个主类
- 使用：new出对象程序中使用
- 卸载：执行垃圾回收
  - 时机：什么时候卸载java类？
    - 执行了System.exit()方法
    - 程序正常执行结束
    - 程序在执行过程中遇到了异常或错误而异常终止
    - 由于操作系统出现错误而导致Java虚拟机进程终止




---
<br /><br /><br />
<img style="border:1px red solid; display:block; margin:0 auto;" src="https://tianqingxiaozhu.oss-cn-shenzhen.aliyuncs.com/img/qrcode.jpg" alt="微信公众号" />
