---
title: "02.JVM运行期内存结构"
category:
  - "core"
tag:
  - "jvm"
---

> Q： 内存结构就内存结构呗，为啥还要加一个运行期？
> 
> A： 很明白咯，JVM除了运行期内存以外，肯定还有所谓的非运行期的内存呗。jdk的功能之一就是把.java文件编译成.class文件，这个过程就是编译过程，那编译过程也是需要内存空间的。所以，我们这里就加个限定词，运行期内存结构。


## 图解

逻辑视图与物理视图的理解可以对比数据结构概念中的逻辑模型与物理模型。逻辑视图可以理解为，jdk开发者为了便于人们更好的理解而展示的一种图，而物理视图可以理解为，jdk开发者实际实现JVM时，所采用的一种视图模型。

### 逻辑视图

![逻辑视图](https://tianqingxiaozhu.oss-cn-shenzhen.aliyuncs.com/img/jvm/jvm-runtime-dataarea-structure.png)

从这张图中可以看出：

1. jvm运行时数据区的相关模块以及各个模块是否线程共享等；
2. jvm的模块分为大概两三个：类加载器模块、运行时数据区、执行模块、本地接口模块等。

### 物理视图

![物理视图](https://tianqingxiaozhu.oss-cn-shenzhen.aliyuncs.com/img/jvm/jvm-runtime-dataarea-param.png)

这张图则展示了运行时数据区的几个重要的区域的结构以及这几个区域的jvm控制参数等。

### 逻辑模型补充模型

![逻辑模型补充模型](https://tianqingxiaozhu.oss-cn-shenzhen.aliyuncs.com/img/jvm/jvm-architecture-detail.png)

这张图则展示了jvm运行时数据区的详细细节。

## JVM运行期内存结构

> Q： 为什么要把运行期内存结构划分成线程私有的区域和线程共享的区域？运行期内存结构跟线程有啥关系？
> 
> A： 我们知道，对于tomcat来说，每一个请求都需要一个线程，直到请求结束。再比如，我们在查看Java Web应用的日志时，我们就可以通过线程id来找到一个请求的完整日志。所以，从这个意义上来讲，线程管理着运行期的内存结构，因此，我们在理解运行期内存结构时，需要与线程联系起来。
> 

实际上，根据『堆管存储，栈管运行』的说法，我们可以人为，JVM运行期内存结构就只有两部分内容，一个是栈、一个是堆。只不过是，人们在JVM的实际实现过程中发现，只有栈和堆是不行的，因此又设计了其他内存区域。

### 程序计数器

- 特征
  - 一块较小的内存空间
  - 执行java方法时才有值，执行native方法值为空
- 存放内容：`当前线程所执行的字节码的行号指示器`或`存放程序运行的下一条指令的地址`
- 是否线程共享：`线程私有`
- OOM的原因及场景：唯一一个没有规定任何OutOfMemoryError的区域
- 控制参数：无
- 为什么要有程序计数器？
  - ​多个线程的运行是通过操作系统随机分配CPU执行的时间片来完成的，那么在切换时间片时，就需要标记被切换的线程下一条指令的地址，这样就保证了这个线程再次获取执行权时，能够找到之前执行到的位置


### 虚拟机栈

- 特征
  - 对于tomcat来说，每一个请求都需要一个线程，直到请求结束。每当jvm需要运行一个线程时，就会在此区域划分出一小块内存给这个线程使用，这一小块内存就是虚拟机栈，工作线程与虚拟机栈一一对应
  - ​代码中的每一个方法就对应着虚拟机栈中的一个栈帧，代码中的方法与栈帧一一对应
  - ​方法的执行和结束对应着栈帧在线程所对应的虚拟机栈中的入栈和出栈操作，但不允许不同线程创建的栈帧之间的相互引用
  - 描述的是`Java方法`执行的内存模型
  - 每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储`局部变量表`、`操作栈`、`动态链接`、`方法出口`和`一些附加信息`等，栈帧跟随方法的调用而创建，随着方法结束而销毁。
    - 局部变量存放了`基本数据`、`类型对象引用`和`returnAddress类型`
- 存放内容：由很多方法执行时创建的一个一个的栈帧，每一个桟帧都包括`局部变量表`、`操作栈`、`动态链接`、`方法出口`
- 是否线程共享：线程私有
- OOM的原因及场景：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），当扩展时无法申请到足够的内存时会抛出OutOfMemoryError异常。
- 控制参数：主要是-Xss

#### 虚拟机栈中的桟帧

桟帧结构包含五部分内容，局部变量表、操作数栈、动态链接、方法出口和一些附加信息。

- 局部变量表

![20230414090827](https://tianqingxiaozhu.oss-cn-shenzhen.aliyuncs.com/blog20230414090827.png)

- 操作数栈 

![20230414090916](https://tianqingxiaozhu.oss-cn-shenzhen.aliyuncs.com/blog20230414090916.png)

- 动态链接

![20230414092102](https://tianqingxiaozhu.oss-cn-shenzhen.aliyuncs.com/blog20230414092102.png)

- 方法出口 

![20230414091057](https://tianqingxiaozhu.oss-cn-shenzhen.aliyuncs.com/blog20230414091057.png)

- 附加信息

![20230414093039](https://tianqingxiaozhu.oss-cn-shenzhen.aliyuncs.com/blog20230414093039.png)


### 本地方法栈

- 本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（譬如Sun HotSpot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。
- Hotspotvm直接把本地方法栈和虚拟机栈合二为一

### 方法区


![20230414101239](https://tianqingxiaozhu.oss-cn-shenzhen.aliyuncs.com/blog20230414101239.png)

![20230414101401](https://tianqingxiaozhu.oss-cn-shenzhen.aliyuncs.com/blog20230414101401.png)

![20230414101648](https://tianqingxiaozhu.oss-cn-shenzhen.aliyuncs.com/blog20230414101648.png)


### Java堆

![20230414102125](https://tianqingxiaozhu.oss-cn-shenzhen.aliyuncs.com/blog20230414102125.png)

![20230414102201](https://tianqingxiaozhu.oss-cn-shenzhen.aliyuncs.com/blog20230414102201.png)

- 特征
  - 是Java虚拟机所管理的内存中最大的一块
  - **是垃圾收集器的主要管理区域**
  - 现在的vm都是使用分代收集算法
    - 可以把java堆分配新生代和老年代，新生代又可以分为eden、s1（from survivor）、s2(to survivor)区域
- 存放内容：存放`对象实例`和`数组`
- 是否线程共享：是
- OOM的原因及场景：
  - 在堆中没有内存完成实例分配，并且堆也无法再扩展时
- 控制参数：-Xmx 和 -Xms、-Xmn、-XX:SurvivorRatio



## 对象的探秘

首先，对象（包括数组对象）基本上都是分配到Java堆上的（逃逸分析时，可能会直接分配到栈上），但是Java堆还细分成好几个部分，具体分配到哪些区域，需要遵循`对象分配规则`。其次明确了对象分配的区域之后，就需要创建对象，所以第二步是要了解`对象的创建过程`。之后是Java代码中的每一部分是如何在堆上进行分布的，这就是`对象的内存分布`。再之后就是需要使用对象，使用对象时涉及到如何对对象进行访问和定位，这就是`对象的访问定位`。最后是在垃圾回收过程中，如何判断新生代对象应该转变成老年代对象，即`对象的升代策略`。

下面四个部分，环环相扣，便于理解。

#### 对象分配规则

- `对象优先分配在Eden区`。如果Eden区没有足够的空间时，虚拟机执行一次Minor GC。
- `大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）`。这样做的目的是避免在Eden区和两个Survivor区之间发生大量的内存拷贝（新生代采用复制算法收集内存）。
- `长期存活的对象进入老年代`。虚拟机为每个对象定义了一个年龄计数器，如果对象经过了1次Minor GC那么对象会进入Survivor区，之后每经过一次Minor GC那么对象的年龄加1，知道达到阀值对象进入老年区。
- `动态判断对象的年龄`。如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代。
- `空间分配担保`。每次进行Minor GC时，JVM会计算Survivor区移至老年区的对象的平均大小，如果这个值大于老年区的剩余值大小则进行一次Full GC，如果小于检查HandlePromotionFailure设置，如果true则只进行Monitor GC,如果false则进行Full GC。

### 对象的创建过程

![20230414102234](https://tianqingxiaozhu.oss-cn-shenzhen.aliyuncs.com/blog20230414102234.png)

![20230414102437](https://tianqingxiaozhu.oss-cn-shenzhen.aliyuncs.com/blog20230414102437.png)


### 对象的内存分布

![20230414111735](https://tianqingxiaozhu.oss-cn-shenzhen.aliyuncs.com/blog20230414111735.png)

### 对象的访问定位

![20230414112919](https://tianqingxiaozhu.oss-cn-shenzhen.aliyuncs.com/blog20230414112919.png)


### 对象的升代策略

![20230414114826](https://tianqingxiaozhu.oss-cn-shenzhen.aliyuncs.com/blog20230414114826.png)

需要注意的是，内存分配策略需要遵循对象升代策略。

### 再谈对象的内存分配过程

> 说明： 以下纯属个人理解，并没有在任何资料上找到相关内容。

对象实例化过程往往都伴随着垃圾回收过程，因此我们可以把对象的内存分配过程分成两部分，一部分是在有垃圾回收之前的首次分配，也就是之前一次也没有使用过这个对象；另一部分是在垃圾回收之后的再次分配，也就是之前使用过这个对象，但是这个对象被垃圾回收器回收掉了。

首次分配过程，对象先经过逃逸分析，判断是否需要优化代码，如果需要优化代码，JVM在分配内存的过程中可能会使用TLAB，直接把对象分配到桟帧上；如果没有使用TLAB进行分配，则可能会根据对象的升代策略，判断是否是大对象、空间分配担保条件是否能满足，如果满足，可能直接分配到老年代；否则的话，可能会把对象直接分配到Eden区域。

再次分配过程时，如果之前使用的是TLAB，再次分配时可能还会使用TLAB进行分配，或者直接分配到老年代，但是分配到老年代的判断条件除了是否是大对象、是否满足空间分配担保条件外，还要动态判断对象的年龄；否则的话，就把对象分配到eden区域。

总结来说，对象的内存分配过程涉及到GC过程，所以对象在内存分配过程时，都要首先经过逃逸分析和对象升代策略之后，才能确定是否会直接分配到Eden区域上。

### 再谈四部分的联系

`对象的内存分配策略（包括对象升代策略）`明确了对象在JVM运行期内存结构中的位置，`对象的创建过程`及`对象的内存分布情况`则回答了如何分配的问题，最后`对象的访问定位`则回答了如何使用的问题。

- 分配在运行期内存结构的哪部分区域：1. 经过逃逸分析，判断是否直接分配在桟帧的TLAB上；2. 经过对象升代策略的条件判断，决定是否直接分配到老年代上；3. 经过前两个阶段分析后，决定是否直接分配在Eden区域；
- 如何分配：对象的创建过程及对象的内存结构情况；
- 如何使用：对象的访问定位；

![20230414125322](https://tianqingxiaozhu.oss-cn-shenzhen.aliyuncs.com/blog20230414125322.png)



本章节中，我们先是从线程的角度去了解jvm内存区域的整体结构，接着我们将了解JVM运行时数据区域，最后我们了解GC主要的作用区域——Java堆的结构。研究的三个部分的范围越来越小。

jvm的内存区域主要包括`线程私有的区域`【程序计数器、本地方法栈、java栈】、`线程共享的区域`【java堆、方法区】、`直接内存`等，**我们平时讨论的是运行时数据区域，也就是除了直接内存以外的其他区域**。

这里，我们提供一种记忆jvm运行期内存模型的方式。我们按照**内存区域是否线程共享**这一原则，将JVM的内存结构划分为三个方面：

- 与线程具有相同生命周期的内存空间
  
这部分内存空间也就是我们所说的`线程私有的内存区域`。这部分内存区域的生命周期与线程相同，依赖用户线程的启动或结束而创建或销毁，换句话说：Hotspotvm中每个用户线程都有自己的内存空间，这部分内存空间的存与否跟随JVM线程的生与死对应。

- 与线程不具有相同的生命周期内存空间
  这部分内存空间被称作`线程共享的内存空间`。这部分内存区域会跟随虚拟机的启动或关闭而创建或销毁。`这部分是GC作用的重点区域，也是我们研究的重点区域。`

- 直接内存
  这部分区域，并不是jvm运行时区域的一部分，但是也被频繁使用：jdk1.4后引入的NIO提供了基于通道和缓存的方式，它可以使用本地函数直接分配堆外内存，然后使用DirectByteBuffer对象作为对这块内存的引用，这样避免了java堆中与native堆来回复制数据，有利于提高性能。

~~**总而言之，线程私有的区域和直接内存区域都是由操作系统直接管理，这使得垃圾回收作用的范围就变得很小了，换句话说，GC作用到的内存区域也就只剩下线程共享的区域了。**~~

### JVM运行时数据区

按照**具体的实际功能**可以将**JVM的运行时数据区域内存结构**划分为以下几方面的内容，我们也将从`存放内容`、`是否是线程共享`、`OOM的原因及场景`、`控制参数`等方面去研究`运行时数据区`的每一部分内容：



### GC时的数据区

java是纯面向对象的语言，这就意味着应用程序中基本都是一个一个的对象，存放类对象的java堆也就成为我们重点要研究的对象，不言而喻的，垃圾回收的作用区域当然也是Java堆了。

#### Java堆的结构

![java堆的内存结构](https://tianqingxiaozhu.oss-cn-shenzhen.aliyuncs.com/img/jvm/java-stack.png)

我们将从以下**存放内容**、**占据大小**、**垃圾回收名称及触发条件**等方面去了解堆区域。

- 新生代（Young区域）
  用来存放新生的对象，它占据整个堆的三分之一的空间，在这个区域上面会频繁触发MinorGC进行垃圾回收。新生代又分为Eden区域、ServivorFrom（也被称为S1）、ServivorTo（也被称为S2）三个区。
  - Eden区
    java新对象的出生地（例外：如果新创建的对象占用内存交代，则直接分配到老年代）；当Eden区域内存不够时就会触发MinorGC
  - ServivorFrom（S1）
    上一次GC的幸存者，与Eden区域一同作为这一次GC的被扫描者
  - ServivorTo（S2）
    保留着了一次MinorGC过程中的幸存者

> 注意：在说明部分的内容时，要特别的指出所使用的垃圾收集器。在使用G1垃圾收集器时，Java堆的内存布局发生很大变化，它将整个java堆划分为多个大小相等的独立区域（Region），虽然还保留新生代和老年代的概念，但是二者已经不是物理隔阂了，他们都是一部分（可以不用连续）Region的集合。

- 老年代（Old区域）
  存放的是应用程序中生命周期长的内存对象，它占据整个堆的三分之二的空间。发生在这块区域的垃圾回收被称为MajorGC（或者FullGC）只有在**新生代对象晋升为老年代导致空间不够时**或者无**法找到足够大的连续空间为大对象分配空间时**才会触发。


---


<img style="border:1px red solid; display:block; margin:0 auto;" src="https://tianqingxiaozhu.oss-cn-shenzhen.aliyuncs.com/img/qrcode.jpg" alt="微信公众号" />
