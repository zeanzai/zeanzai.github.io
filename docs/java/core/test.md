---
title: "职业发展道路上的一些坑"
category:
  - "resume"
tag:
  - "advice"
---


- OOM
  - OOM类型
    - 服务器异常
      - Swap分区
        - 异常类型
          - Out of swap space
        - 本质原因
          - Linux系统会把不常用的内存里面的数据放到一个swap分区中，这样再次使用这些数据时，就直接从swap分区中读到内存中就行，即交换分区。虚拟内存（Virtual Memory）由物理内存（Physical Memory）和交换空间（Swap Space）两部分组成，遇到这个异常，表示虚拟内存耗尽。
        - 常见具体原因
          - 地址空间不足
          - 物理内存耗尽
          - 应用程序的本地内存泄露（native leak），例如不断申请内存空间，却不释放
        - 优化手段
          - 执行 jmap -histo:live <pid> 命令，强制执行FullGC，如果几次执行后内存明显下降，则基本可以确认为 Direct buffer 问题
          - 升级地址空间为64bit
          - 升级服务器配置规格或进行资源隔离
      - 线程资源
        - 异常类型
          - Unable to create new native thread
        - 本质原因
          - JVM创建的用户线程都是由底层操作系统来完成的，而操作系统创建线程需要分配空间，当JVM创建系统线程，而操作系统又没有足够资源分配时，就会抛出异常信息。
        - 常见的具体原因
          - JVM创建的线程数超过了操作系统的ulimit限制
          - 线程数超过了kernel.pid_max
          - 本地线程内存空间不足
        - 优化手段
          - 调整ulimit限制，ulimit -u xxx
          - 减小JVM其他资源使用，腾出更多空间给线程使用
            - 限制线程栈大小，即调小-Xss大小
            - 减小堆空间大小
            - 限制线程池大小
          - 修复其他应用程序内存泄露问题
      - OOM Killer机制
        - 异常类型
          - Kill process or sacrifice child
        - 本质原因
          - 默认情况下，Linux允许用户进程申请大于系统可用内存的空间，这样可以『错峰复用』，有利于提高资源利用率。但这也导致了『超卖』问题，因此当线程申请不到资源时，系统会自动激活OOM Killer机制，寻找评分较低的进程来释放资源。在监控工具上的表现是：空闲的内存空间突然大幅度上升
        - 常见的具体原因
          - 这个异常类型是由操作系统层面出发的，也就是操作系统自动触发的OOM Killer机制导致的异常
        - 优化手段
          - 可以采用资源隔离或对系统OOM Killer机制进行调优
    - Java堆
      - 内存泄露或内存溢出
        - 异常类型
          - Java heap space
        - 本质原因
          - 堆空间没有足够的空间存放新创建的对象时，就会抛出异常信息
        - 常见的具体原因
          - 请求创建一个大对象，通常是一个大数组
          - 业务流量激增，这种情况需要配合监控工具中的尖峰值时期与OOM时期来判断是否是因为业务流量激增导致的
          - 过度使用终结器（Finalizer），该对象没有立即被 GC
          - 内存泄漏（Memory Leak），大量对象引用没有释放，JVM 无法对其自动回收，常见于使用了 File 等资源没有回收
        - 优化手段
          - 通常是调高JVM堆内存空间即可，还是不行就采用下面的手段
          - 超大对象，就要检查业务代码，判断其合理性
          - 如果是业务峰值，就扩大资源，或做限流熔断等
          - 如果是内存泄露，需要找到持有的对象，修改代码设计，比如关闭没有释放的资源等
      - 多次GC仍无法满足分配资源所需要的空间
        - 异常类型
          - GC overhead limit exceeded
        - 本质原因
          - JVM花费了98%的GC时间回收不到2%的内存空间，换句话来说应用程序已经耗尽了所有可用内存，连GC也不会回收
        - 优化手段
          - 同 Java heap space
      - 数组越界
        - 异常类型
          - Requested array size exceed VM limit
        - 本质原因
          - 程序请求创建的数组超过最大长度限制抛出异常
        - 优化手段
          - 检查代码，判断合理性，或改为分批次执行等
      - 发生的时机不同，GC overhead limit exceeded 发生时，可能并没有申请内存空间使用，只是多次GC后回收的内存空间过小；而 Java heap space 发生时，一定会有JVM为完成对象的创建而申请内存空间分配
    - 方法区
      - 方法区已满
      - 本质原因
        - 方法区已满，通常是加载的class数目太多或体积太大
      - 异常类型
        - 永久代/老年代
          - 永久代空间已满
            - Permgen space
        - 元空间
          - 元空间已满
            - Metaspace
      - 优化手段
        - 根据出现的时机采用不同的办法
          - 程序启动时，调整 -XX:MaxPermSize 或 -XX:MaxMetaspaceSize 启动参数，调大方法区的大小
          - 应用重新部署时，应用没有重新启动，导致加载了多份class信息，再次重启即可
          - 运行时报错，可能是应用程序动态创建了大量的class，而这些class生命周期却很短暂，但是jvm并没有卸载class，可以配置 -XX:+CMSClassUnloadingEnabled 和 -XX:+UseConcMarkSweepGC 两个参数，允许JVM卸载class
          - 如果上面还不能解决，就是用 jmap -dump:format=b,file=dump.hprof <process-id> 命令dump内存对象，然后通过MAT工具分析开销最大的classloader及重复的class
    - 直接内存
      - JVM允许应用程序通过 Direct byte buffer 直接访问堆外内存，一些应用程序通过 Direct byte buffer 结合内存映射文件（memory mapped file）实现高速IO。Direct byte buffer 默认的大小是64MB，一旦超出这个限制，就会抛出异常。通常情况下，涉及到Nio操作时才会抛错。
      - 异常类型
        - Direct buffer memory
      - 本质原因
        - 应用程序使用Direct byte buffer时，超出了限制
      - 优化手段
        - 通过 -XX:MaxDirectMemorySize 启动参数，调整直接内存的大小
        - 检查堆外内存使用代码，确认是否存在内存泄露；或通过反射调用sun.misc.Cleaner的clean()方法，主动释放被 Direct ByteBuffer 持有的内存空间
        - Java只能通过ByteBuffer.allocateDirect来操作Direct ByteBuffer，因此可以通过Arthas拦截改方法进行排查
        - 检查一下 -XX:+DisableExplicitGC 参数是否启动，如果有就去掉，因为这个参数会让 System.gc() 失效
- StackOverFlow