---
"title": "jvm学习笔记"
category:
  - "core"
tag:
  - "jvm"
---

## 运行期的内存数据区域

![运行期内存数据结构](https://tianqingxiaozhu.oss-cn-shenzhen.aliyuncs.com/blog20221212120517.png)

- 编译期也会使用到内存，但是这个阶段主要是把java语言编译成可供机器识别的机器码，它的内存的分配以及回收可由具体的虚拟机的实现来进行管理；并且这个过程主要由程序猿的代码平台或编译工具来完成，因此它相较于运行期的内存数据区域就显得不那么重要了。
- 这个区域是为了解决垃圾回收而产生的一个概念。
- 根据是否由用户线程共享使用把运行期内存数据区域划分为两部分
  - 用户线程共享的区域（事先规定好总量的大小，来一个用户线程就划分一块区域给这个线程使用，与用户线程是一对多的关系，即一个区域对应多个用户线程）
    - `方法区`
      - 保存类型信息、常量、静态变量、即时编译产生的代码缓存等
      - 早期版本中有永久代的概念，是为了像管理堆一样管理方法区，但这种设计更容易遇到内存溢出的问题，于是后期版本中废弃了永久代的概念
      - 这部分的回收目标是针对常量池（主要存放各种字面量和符号引用以及符号引用的直接引用）的回收和类型卸载，回收效果差强人意
      - 当无法满足新的内存分配需求时会抛出OOM异常
    - `Java堆`
      - 主要存放各种对象和数组
      - 是由一个个TLAB组成，在内存中可以连续，也可以不连续，为了回收和访问效率，可能会要求大对象在内存上连续
      - “新生代”、“老年代”、“Eden区”、“Surivivor区”等都是具体的垃圾回收器在回收内存空间时对堆上存储内容的再次划分，不能说运行期内存就有这部分区域
      - 一般通过“-Xmx”和“-Xmx”设定，当没有多余的内存空间分配时且堆无法进行扩展时会抛出OOM异常
  - 用户线程私有的区域（与用户线程是一对一的关系，重要特征是会随着用户线程的消亡而消亡）
    - `PC计数器`
      - 字节码的行号指示器，用来标记线程切换后的执行位置
      - 没有OOM异常
    - `虚拟机栈`
      - 只存放栈帧，Java中方法的执行对应着栈帧的入栈和出栈
      - 栈帧中存放着局部变量表、操作数栈、动态链接和方法的出口等
      - 局部变量存放着基本数据类型、对象类型和方法返回等
      - 而基本数据类型是以Slot为基本单位进行分配的，long和double占2个Slot，其余全部是1个Slot
      - 执行一个方法请求时，这个请求的线程会根据方法区的类型描述创建一个又一个栈帧，请求结束，线程会释放这里的空间
      - 使用相关工具观察jvm运行期内存区域时，会发现此区域会随着请求的变化而变化
      - 一般通过“-Xss”进行设定，当线程请求的栈的深度大于虚拟机所允许的最大深度或者栈扩展时无法申请到足够的内存时会抛出OOM异常
    - `本地方法栈`
      - 与虚拟机栈类似，但存放的内容是本地方法的相关内容
    - `直接内存`
      - 例如在NIO中会直接使用Native函数分配直接内存，然后使用DirectByteBuffer进行操作，使用完成后由线程直接释放
      - 受到物理内存大小的限制，也会产生OOM

## 对象的创建过程

1. 先去常量池中检查是否能够定位到一个类的符号饮用，然后检查是否被加载、解析和初始化，没有的话就先执行类加载过程
2. 通过指针碰撞、空闲列表和TLAB技术为新生代分配内存
3. 把划分好的内存区域初始化为零值
4. 进行必要的设置（实例对象的类对象信息、元数据信息的定位、对象的哈希码、对象的GC分代年龄）
5. 执行init方法，完成其它资源和状态信息的构造

## 对象的内存分布是怎样的？


## 访问对象时是如何定位对象的？

- `句柄池方式`，在Java堆中划分一块区域作为句柄池，主要存放对象实例信息和对象类型信息
  - 对象实例信息指向堆中某块区域
  - 对象类型信息指向方法区中某块区域
- `直接指针方式`，栈帧的本地变量表中直接存放对象的内存布局的地址，比着句柄池的方式少了一次饮用，积少成多的情况下也会带来非常可观的收益


## 对象的回收

- 明确垃圾回收的目标区域—Java堆
  - 明确需要回收的区域有哪些？【线程共享的区域】
    - PC计数器、虚拟机栈（栈帧在类结构确定下来时即可已知）、本地方法栈均会随着线程的生存而生存，也会随着线程的消亡而消亡，所以`这几块区域的内存分配与回收具有确定性`
    - 一个接口的多个实现类所需要的内存空间可能不一样，一个方法的不同判断条件的分支所需要的内存空间也可能不一样，因此`Java堆和方法区的内存分配和回收具有不确定性`
  - 方法区回收主要是回收废弃的常量和不再使用的类型，此区域的回收性价比很低，一般情况下优化的空间较小，因此`Java堆就成了垃圾回收重点关注的区域`
- 垃圾回收的理论基石
  - 统计出所有需要回收的对象
    - 引用计数法
    - 可达性分析：通过GCRoot作为引用根对象，向下扫描，当某个对象没有任何引用链相连时，就说明此对象可以进行回收；
      - 可以作为GCRoot的对象有
        - 虚拟机栈中的局部变量表中引用的对象
        - 本地方法栈中引用的对象
        - 方法区中静态变量引用的对象、常量引用的对象
        - 虚拟机内部的引用
        - 被同步锁持有的对象
        - 反应Java虚拟机内部情况的jmxBean、JVMTI中注册的回调、代码缓存等
      - 引用的分类
        - 强： 不会被回收
        - 软： 内存不够时才会回收
        - 弱： 下次垃圾回收时一定会被回收
        - 虚： 垃圾回收时收到系统的通知
      - 标记线程的两次标记过程
        - 第一次： 发现没有被GCRoot引用的对象
        - 第二次： 代码覆盖到finalize()方法，则对象放入F-Queue中，虚拟机开辟一个调度优先级低的线程依次触发F-Queue队列中的对象的finalize()方法，如果对象还没有GCRoot引用，则标记该对象可回收
  - 回收垃圾对象的过程
    - 分代收集
      - 实践证明的三条原理
        - 绝大多数对象朝生夕灭的
        - 熬过多次GC后的对象更难消亡
        - 跨代引用相对于同代引用只占少数比例
      - 基于上述三条实践原理，把对象分为年轻代、老年代
      - 分代收集的优缺点
        - 垃圾回收的关注点由如何标记需要回收的数量巨大的对象变成如何保存不需要回收的少量对象，这样就能以较低的代价回收大量的空间；
        - 相比着不采用分代收集的方式，整个回收时间更少，也有利于针对性的设计不同的回收算法；
        - 但是，对象不是孤立的，需要解决对象之间存在的跨代引用的问题；
    - 标记-清除
      - 先标记，后清除被标记的内存空间
      - 会产生内存碎片，执行效率也不稳定，需要收集的对象较多时，效率很低，需要收集的对象较少时，效率就会稍高些；
    - 标记-复制
      - 把s0中要回收的对象进行标记，之后复制到s1中
      - 回收高效，但需要额外的一块区域
    - 标记-整理
      - 让所有存活的对象向内存空间一端移动，然后清理掉边界以外的内存

## HotSpot的实现

- 统计出所有需要回收的对象【Java堆上保存的就是Java对象，要回收当然就要统计出所有需要回收的对象】
  - 枚举根节点
    - 迄今为止，所有收集器在枚举根节点这一步骤都是必须暂停用户线程的（jvm中在垃圾回收的时候单独开辟一个线程去收集垃圾的，在收集的过程中，用户线程在不断产生新的垃圾，因此需要暂停用户线程），如果根节点过多，那么收集就会耗费很长时间，也就是暂停时间过长，那么势必会影响整个jvm的吞吐量，因此一定会有一个地方存放着；
    - HotSpot的解决方案中，会使用一组称为OopMap的数据结构来达到这个目的，在类加载完成的时候，HotSpot就会把对象内什么偏移量上是什么类型的数据计算出来，在即使编译过程中，也会在特定的位置记录下栈里和寄存器里哪些位置是引用
  - 更新记忆集
    - 所有涉及到部分区域收集行为的垃圾收集器，都会`面临着非收集区域指向收集区域的跨区域引用的问题`；
    - 额外开辟一块内存区域，然后创建一种数据结构，就记录非收集区域指向收集区域的指针或引用，这种数据结构就叫记忆集；每次垃圾回收时，只需要关注记忆集和根节点就行，免去了每次都要扫描全部区域的麻烦
    - 简单来说，就是对收集区域进行划分，然后进行编号，之后就会形成一个数组，如果此区域包含了跨代引用或跨区域引用的对象，那么这个位置的值就设置为1，这样每次进行回收的时候，碰到为1的位置就不进行回收了，这样形成的数组就是卡表；
    - 卡表由很多中具体的实现方式，可以卡对象的精度，也可以卡内存快的精度，还可以卡字长的精度。所谓卡对象的精度，就是对对象进行编号，存在跨代引用就把这个编号的值置为1，卡字长的精度，就是根据jvm的字长进行编号；
    - 更新记忆集的时候也是会产生并发一致性的问题，即在垃圾回收需要读取记忆集信息的时候，会同时产生新的引用信息；HotSpot是使用写屏障的技术手段来解决这个问题的；
    - 使用AOP的思想，在对象赋值操作时，对卡表进行更新，即在对象赋值操作时建立切面，然后生成更新卡表的代码语句；
  - 三色标记
    - 收集线程所产生的开销会随着收集区域的扩大而扩大，这会造成jvm吞吐量的下降；
    - 收集线程在进行第二次标记时，用户线程也在重新建立引用或删除引用，即第二次标记时，对象引用关系发生了改变，采用三色标记方式进行解决；
      - 黑色：第一次标记时，被垃圾回收器访问过，且这个对象的所有引用都被扫描过，那么把这个对象标记为黑色；
      - 灰色：第一次标记时，被垃圾回收器访问过，但是至少有一个引用还没有被扫描到，那么就把这个对象标记为灰色；
      - 白色：第一次标记时，没有被垃圾回收器访问过，那么就把这个对象标记为白色；
    - 第二次标记完成后，所有的灰色对象要么变成白色、要么变成灰色，之后垃圾回收器只需要回收白色对象，下次垃圾回收会再次忽略黑色对象，直接从白色对象进行第二次标记；
- 回收的时机
  - 安全点：虚拟机会选取一些能够长时间执行的指令作为安全点，并在安全点处采用主动中断的方式挂起所有用户线程（主动中断就是用户线程主动去轮询一个GC标志位，如果标志位为真，表示要进行GC回收，此时用户线程就会主动中断）
  - 安全区域： 只有安全点的概念，会使主动中断等待的时间过程（GC线程等待所有用户线程都到达安全点才主动中断），试想在一个区域内才更加合理；
- 如何回收
  - 就是利用分代收集的理论分别进行回收


## 垃圾收集器

![垃圾收集器](https://tianqingxiaozhu.oss-cn-shenzhen.aliyuncs.com/blog20221216210422.png)




https://www.douyin.com/aweme/v1/play/?video_id=v0200fg10000ca4bp3bc77u3srd46ocg&line=0&file_id=ef5902a98be442b3b7ebdb3caf867b91&sign=68fc7ef8230364c6a32f95a52de70541&is_play_url=1&source=PackSourceEnum_PUBLISH&aid=6383







<img style="border:1px red solid; display:block; margin:0 auto;" :src="$withBase('/qrcode.jpg')" alt="微信公众号" />


