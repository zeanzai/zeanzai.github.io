<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-beta.38" />
    <meta name="theme" content="VuePress Theme Hope" />
    <meta property="og:url" content="https://zeanzai.me/java/notes/jvm.html"><meta property="og:site_name" content="天晴小猪"><meta property="og:title" content="葛一鸣-深入理解JVM-学习笔记"><meta property="og:type" content="article"><meta property="og:updated_time" content="2023-08-17T04:43:51.000Z"><meta property="og:locale" content="zh-CN"><meta property="article:tag" content="jvm"><meta property="article:modified_time" content="2023-08-17T04:43:51.000Z"><link rel="stylesheet" href="//at.alicdn.com/t/font_2410206_mfj6e1vbwo.css"><title>葛一鸣-深入理解JVM-学习笔记 | 天晴小猪</title><meta name="description" content="天晴小猪 | 关于后端与架构设计 | Software Engineer | Backend | JAVA | DevOps | Linux | IDEA | Microservice | 我活在世上，无非想要明白些道理，遇见些有趣的事。倘能如我所愿，我的一生就算成功。">
    <style>
      :root {
        --bg-color: #fff;
      }

      html[data-theme="dark"] {
        --bg-color: #1d2025;
      }

      html,
      body {
        background-color: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.querySelector("html").setAttribute("data-theme", "dark");
      }
    </script>
    <link rel="stylesheet" href="/assets/style.fac109b7.css">
    <link rel="modulepreload" href="/assets/app.77a131fa.js"><link rel="modulepreload" href="/assets/jvm.html.cc548f9a.js"><link rel="modulepreload" href="/assets/jvm.html.906bb783.js"><link rel="modulepreload" href="/assets/plugin-vue_export-helper.21dcd24c.js">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="skip-link sr-only">Skip to content</a><!--]--><div class="theme-container has-toc sidebar-open"><!--[--><header class="navbar"><button class="toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><a href="/" class="home-link"><img class="logo" src="/logo.JPG" alt="天晴小猪"><!----><span class="site-name hide-in-pad">天晴小猪</span><!--[--><!----><!--]--></a><nav class="nav-links" style=""><div class="nav-item hide-in-mobile"><a href="/java/" class="nav-link active" aria-label="Java面试宝典"><i class="icon iconfont icon-java"></i>Java面试宝典<!----></a></div><div class="nav-item hide-in-mobile"><a href="/springcloud-alibaba/" class="nav-link" aria-label="SpringCloud-Alibaba实战"><i class="icon iconfont icon-code"></i>SpringCloud-Alibaba实战<!----></a></div><div class="nav-item hide-in-mobile"><a href="/question/" class="nav-link" aria-label="面试自查宝典"><i class="icon iconfont icon-quote"></i>面试自查宝典<!----></a></div><div class="nav-item hide-in-mobile"><a href="/linux/" class="nav-link" aria-label="开发环境手册"><i class="icon iconfont icon-customize"></i>开发环境手册<!----></a></div><div class="nav-item hide-in-mobile"><a href="/slashteen/" class="nav-link" aria-label="副业之路"><i class="icon iconfont icon-java"></i>副业之路<!----></a></div></nav><div class="nav-actions-wrapper"><!--[--><!----><!--]--><div class="nav-item"><!----></div><div class="nav-item"><a class="repo-link" href="https://github.com/zeanzai/zeanzai.github.io" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewbox="0 0 1024 1024" aria-labelledby="github" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><title id="github" lang="en">github icon</title><g fill="currentColor"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></g></svg></a></div><div class="nav-item hide-in-mobile"><button id="appearance-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewbox="0 0 1024 1024" aria-labelledby="auto" style="display:block;"><title id="auto" lang="en">auto icon</title><g fill="currentColor"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></g></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewbox="0 0 1024 1024" aria-labelledby="dark" style="display:none;"><title id="dark" lang="en">dark icon</title><g fill="currentColor"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></g></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewbox="0 0 1024 1024" aria-labelledby="light" style="display:none;"><title id="light" lang="en">light icon</title><g fill="currentColor"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></g></svg></button></div><!----><button class="toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span class="button-container"><span class="button-top"></span><span class="button-middle"></span><span class="button-bottom"></span></span></button><!--[--><!----><!--]--></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow left"></span></div><aside class="sidebar"><!--[--><!----><!--]--><ul class="sidebar-links"><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">零、面试前准备</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">一、计算机基础</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">二、JavaCore</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">三、框架</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">四、中间件</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">五、分布式</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">六、源码系列</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">七、项目实战</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable active"><!----><span class="title">八、学习笔记</span><span class="arrow down"></span></button><ul class="sidebar-links"><li><!--[--><a href="/java/notes/distribute-system-theory.html" class="nav-link sidebar-link sidebar-page" aria-label="《分布式技术原理与实战45讲》"><!---->《分布式技术原理与实战45讲》<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/java/notes/c2c.html" class="nav-link sidebar-link sidebar-page" aria-label="《C2C 电商系统微服务架构 120 天实战训练营》"><!---->《C2C 电商系统微服务架构 120 天实战训练营》<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-current="page" href="/java/notes/jvm.html" class="router-link-active router-link-exact-active nav-link active sidebar-link sidebar-page active" aria-label="《深入理解JVM-葛一鸣》"><!---->《深入理解JVM-葛一鸣》<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/java/notes/jvm.html#总述" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="总述"><!---->总述<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/java/notes/jvm.html#编译" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="编译"><!---->编译<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/java/notes/jvm.html#类的加载" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="类的加载"><!---->类的加载<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/java/notes/jvm.html#jvm的内存结构" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="JVM的内存结构"><!---->JVM的内存结构<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/java/notes/jvm.html#jvm中的垃圾回收" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="JVM中的垃圾回收"><!---->JVM中的垃圾回收<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/java/notes/jvm.html#jvm中的并发" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="JVM中的并发"><!---->JVM中的并发<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/java/notes/jvm.html#实战" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="实战"><!---->实战<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/java/notes/jvm.html#业务异常" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="业务异常"><!---->业务异常<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/java/notes/jvm.html#jvm调优" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="JVM调优"><!---->JVM调优<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/java/notes/jvm.html#自己总结的jvm提纲" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="自己总结的JVM提纲"><!---->自己总结的JVM提纲<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/java/notes/jvm.html#思考题" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="思考题"><!---->思考题<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/java/notes/jvm.html#day01-初识jvm" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="day01-初识JVM"><!---->day01-初识JVM<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/java/notes/jvm.html#jvm的概念" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="jvm的概念"><!---->jvm的概念<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/java/notes/jvm.html#jvm发展历史" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="jvm发展历史"><!---->jvm发展历史<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/java/notes/jvm.html#jvm种类" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="jvm种类"><!---->jvm种类<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/java/notes/jvm.html#java语言规范" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="java语言规范"><!---->java语言规范<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/java/notes/jvm.html#jvm规范" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="jvm规范"><!---->jvm规范<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/java/notes/jvm.html#day02-jvm运行机制" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="day02-JVM运行机制"><!---->day02-JVM运行机制<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/java/notes/jvm.html#jvm的启动流程" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="jvm的启动流程"><!---->jvm的启动流程<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/java/notes/jvm.html#jvm的基本结构" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="jvm的基本结构"><!---->jvm的基本结构<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/java/notes/jvm.html#jvm的内存模型" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="jvm的内存模型"><!---->jvm的内存模型<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/java/notes/jvm.html#编译运行和解释运行的区别" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="编译运行和解释运行的区别"><!---->编译运行和解释运行的区别<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/java/notes/jvm.html#day03-常用jvm配置参数" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="day03-常用JVM配置参数"><!---->day03-常用JVM配置参数<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/java/notes/jvm.html#day04-gc算法和种类" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="day04-GC算法和种类"><!---->day04-GC算法和种类<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/java/notes/jvm.html#gc的概念" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="GC的概念"><!---->GC的概念<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/java/notes/jvm.html#gc的算法" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="GC的算法"><!---->GC的算法<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/java/notes/jvm.html#可触及性" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="可触及性"><!---->可触及性<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/java/notes/jvm.html#stop-the-world" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="stop-the-world"><!---->stop-the-world<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/java/notes/jvm.html#day05-gc参数" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="day05-GC参数"><!---->day05-GC参数<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/java/notes/jvm.html#堆的回顾" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="堆的回顾"><!---->堆的回顾<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/java/notes/jvm.html#串行收集器" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="串行收集器"><!---->串行收集器<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/java/notes/jvm.html#并行收集器" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="并行收集器"><!---->并行收集器<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/java/notes/jvm.html#cms收集器" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="CMS收集器"><!---->CMS收集器<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/java/notes/jvm.html#gc参数整理" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="GC参数整理"><!---->GC参数整理<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/java/notes/jvm.html#tomcat实例演示" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Tomcat实例演示"><!---->Tomcat实例演示<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/java/notes/jvm.html#full-gc-和-minor-gc的区别" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="full GC 和 minor GC的区别"><!---->full GC 和 minor GC的区别<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/java/notes/jvm.html#day06-类加载器" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="day06-类加载器"><!---->day06-类加载器<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/java/notes/jvm.html#class装载验证流程" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="class装载验证流程"><!---->class装载验证流程<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/java/notes/jvm.html#什么是类装载器classloader" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="什么是类装载器ClassLoader"><!---->什么是类装载器ClassLoader<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/java/notes/jvm.html#jdk中classloader默认设计模式" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="jdk中ClassLoader默认设计模式"><!---->jdk中ClassLoader默认设计模式<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/java/notes/jvm.html#打破常规模式" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="打破常规模式"><!---->打破常规模式<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/java/notes/jvm.html#热替换" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="热替换"><!---->热替换<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/java/notes/jvm.html#day07-性能监控工具" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="day07-性能监控工具"><!---->day07-性能监控工具<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/java/notes/jvm.html#性能监控工具" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="性能监控工具"><!---->性能监控工具<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/java/notes/jvm.html#day08-java堆分析" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="day08-java堆分析"><!---->day08-java堆分析<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/java/notes/jvm.html#java堆分析" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="java堆分析"><!---->java堆分析<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li></ul><!--]--></li><li><!--[--><a href="/java/notes/redis.html" class="nav-link sidebar-link sidebar-page" aria-label="《Redis 核心原理与实战》"><!---->《Redis 核心原理与实战》<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/java/notes/guli.html" class="nav-link sidebar-link sidebar-page" aria-label="谷粒商城学习笔记"><!---->谷粒商城学习笔记<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">九、工作技巧</span><span class="arrow right"></span></button><!----></section><!--]--></li></ul><!--[--><!----><!--]--></aside><!--[--><main class="page" id="main-content"><!----><nav class="breadcrumb disable"></nav><div class="page-title"><h1><!---->葛一鸣-深入理解JVM-学习笔记</h1><div class="page-info"><span class="author-info" aria-label="作者🖊" data-balloon-pos="down" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewbox="0 0 1024 1024" aria-labelledby="author"><title id="author" lang="en">author icon</title><g fill="currentColor"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></g></svg><span><a class="author-item" href="https://zeanzai.me" target="_blank" rel="noopener noreferrer">天晴小猪</a></span><span property="author" content="天晴小猪"></span></span><!----><span class="date-info" aria-label="写作日期📅" data-balloon-pos="down" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewbox="0 0 1024 1024" aria-labelledby="calendar"><title id="calendar" lang="en">calendar icon</title><g fill="currentColor"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></g></svg><span>2023年8月17日</span><meta property="datePublished" content="2023-08-17T04:43:51.000Z"></span><span class="category-info" aria-label="分类🌈" data-balloon-pos="down" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon category-icon" viewbox="0 0 1024 1024" aria-labelledby="category"><title id="category" lang="en">category icon</title><g fill="currentColor"><path d="M148.41 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H148.41c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.311-40.31zM147.556 553.478H429.73c22.263 0 40.311 18.048 40.311 40.31v282.176c0 22.263-18.048 40.312-40.31 40.312H147.555c-22.263 0-40.311-18.049-40.311-40.312V593.79c0-22.263 18.048-40.311 40.31-40.311zM593.927 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H593.927c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.31-40.31zM730.22 920.502H623.926c-40.925 0-74.22-33.388-74.22-74.425V623.992c0-41.038 33.387-74.424 74.425-74.424h222.085c41.038 0 74.424 33.226 74.424 74.067v114.233c0 10.244-8.304 18.548-18.547 18.548s-18.548-8.304-18.548-18.548V623.635c0-20.388-16.746-36.974-37.33-36.974H624.13c-20.585 0-37.331 16.747-37.331 37.33v222.086c0 20.585 16.654 37.331 37.126 37.331H730.22c10.243 0 18.547 8.304 18.547 18.547 0 10.244-8.304 18.547-18.547 18.547z"></path></g></svg><ul class="categories-wrapper"><li class="category category5 clickable" role="navigation">notes</li><meta property="articleSection" content="notes"></ul></span><span aria-label="标签🏷" data-balloon-pos="down" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon tag-icon" viewbox="0 0 1024 1024" aria-labelledby="tag"><title id="tag" lang="en">tag icon</title><g fill="currentColor"><path d="M939.902 458.563L910.17 144.567c-1.507-16.272-14.465-29.13-30.737-30.737L565.438 84.098h-.402c-3.215 0-5.726 1.005-7.634 2.913l-470.39 470.39a10.004 10.004 0 000 14.164l365.423 365.424c1.909 1.908 4.42 2.913 7.132 2.913s5.223-1.005 7.132-2.913l470.39-470.39c2.01-2.11 3.014-5.023 2.813-8.036zm-240.067-72.121c-35.458 0-64.286-28.828-64.286-64.286s28.828-64.285 64.286-64.285 64.286 28.828 64.286 64.285-28.829 64.286-64.286 64.286z"></path></g></svg><ul class="tags-wrapper"><li class="tag tag2 clickable" role="navigation">jvm</li></ul><meta property="keywords" content="jvm"></span><span class="reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="down" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewbox="0 0 1024 1024" aria-labelledby="timer"><title id="timer" lang="en">timer icon</title><g fill="currentColor"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></g></svg><span>大约 27 分钟</span><meta property="timeRequired" content="PT27M"></span></div><hr></div><div class="toc-place-holder"><aside id="toc-list"><div class="toc-header">此页内容</div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/java/notes/jvm.html#总述" class="router-link-active router-link-exact-active toc-link level2">总述</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/java/notes/jvm.html#编译" class="router-link-active router-link-exact-active toc-link level2">编译</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/java/notes/jvm.html#类的加载" class="router-link-active router-link-exact-active toc-link level2">类的加载</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/java/notes/jvm.html#jvm的内存结构" class="router-link-active router-link-exact-active toc-link level2">JVM的内存结构</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/java/notes/jvm.html#jvm中的垃圾回收" class="router-link-active router-link-exact-active toc-link level2">JVM中的垃圾回收</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/java/notes/jvm.html#jvm中的并发" class="router-link-active router-link-exact-active toc-link level2">JVM中的并发</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/java/notes/jvm.html#实战" class="router-link-active router-link-exact-active toc-link level2">实战</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/java/notes/jvm.html#业务异常" class="router-link-active router-link-exact-active toc-link level3">业务异常</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/java/notes/jvm.html#jvm调优" class="router-link-active router-link-exact-active toc-link level3">JVM调优</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/java/notes/jvm.html#自己总结的jvm提纲" class="router-link-active router-link-exact-active toc-link level2">自己总结的JVM提纲</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/java/notes/jvm.html#思考题" class="router-link-active router-link-exact-active toc-link level2">思考题</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/java/notes/jvm.html#day01-初识jvm" class="router-link-active router-link-exact-active toc-link level2">day01-初识JVM</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/java/notes/jvm.html#jvm的概念" class="router-link-active router-link-exact-active toc-link level3">jvm的概念</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/java/notes/jvm.html#jvm发展历史" class="router-link-active router-link-exact-active toc-link level3">jvm发展历史</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/java/notes/jvm.html#jvm种类" class="router-link-active router-link-exact-active toc-link level3">jvm种类</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/java/notes/jvm.html#java语言规范" class="router-link-active router-link-exact-active toc-link level3">java语言规范</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/java/notes/jvm.html#jvm规范" class="router-link-active router-link-exact-active toc-link level3">jvm规范</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/java/notes/jvm.html#day02-jvm运行机制" class="router-link-active router-link-exact-active toc-link level2">day02-JVM运行机制</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/java/notes/jvm.html#jvm的启动流程" class="router-link-active router-link-exact-active toc-link level3">jvm的启动流程</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/java/notes/jvm.html#jvm的基本结构" class="router-link-active router-link-exact-active toc-link level3">jvm的基本结构</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/java/notes/jvm.html#jvm的内存模型" class="router-link-active router-link-exact-active toc-link level3">jvm的内存模型</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/java/notes/jvm.html#编译运行和解释运行的区别" class="router-link-active router-link-exact-active toc-link level3">编译运行和解释运行的区别</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/java/notes/jvm.html#day03-常用jvm配置参数" class="router-link-active router-link-exact-active toc-link level2">day03-常用JVM配置参数</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/java/notes/jvm.html#day04-gc算法和种类" class="router-link-active router-link-exact-active toc-link level2">day04-GC算法和种类</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/java/notes/jvm.html#gc的概念" class="router-link-active router-link-exact-active toc-link level3">GC的概念</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/java/notes/jvm.html#gc的算法" class="router-link-active router-link-exact-active toc-link level3">GC的算法</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/java/notes/jvm.html#可触及性" class="router-link-active router-link-exact-active toc-link level3">可触及性</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/java/notes/jvm.html#stop-the-world" class="router-link-active router-link-exact-active toc-link level3">stop-the-world</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/java/notes/jvm.html#day05-gc参数" class="router-link-active router-link-exact-active toc-link level2">day05-GC参数</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/java/notes/jvm.html#堆的回顾" class="router-link-active router-link-exact-active toc-link level3">堆的回顾</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/java/notes/jvm.html#串行收集器" class="router-link-active router-link-exact-active toc-link level3">串行收集器</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/java/notes/jvm.html#并行收集器" class="router-link-active router-link-exact-active toc-link level3">并行收集器</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/java/notes/jvm.html#cms收集器" class="router-link-active router-link-exact-active toc-link level3">CMS收集器</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/java/notes/jvm.html#gc参数整理" class="router-link-active router-link-exact-active toc-link level3">GC参数整理</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/java/notes/jvm.html#tomcat实例演示" class="router-link-active router-link-exact-active toc-link level3">Tomcat实例演示</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/java/notes/jvm.html#full-gc-和-minor-gc的区别" class="router-link-active router-link-exact-active toc-link level3">full GC 和 minor GC的区别</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/java/notes/jvm.html#day06-类加载器" class="router-link-active router-link-exact-active toc-link level2">day06-类加载器</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/java/notes/jvm.html#class装载验证流程" class="router-link-active router-link-exact-active toc-link level3">class装载验证流程</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/java/notes/jvm.html#什么是类装载器classloader" class="router-link-active router-link-exact-active toc-link level3">什么是类装载器ClassLoader</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/java/notes/jvm.html#jdk中classloader默认设计模式" class="router-link-active router-link-exact-active toc-link level3">jdk中ClassLoader默认设计模式</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/java/notes/jvm.html#打破常规模式" class="router-link-active router-link-exact-active toc-link level3">打破常规模式</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/java/notes/jvm.html#热替换" class="router-link-active router-link-exact-active toc-link level3">热替换</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/java/notes/jvm.html#day07-性能监控工具" class="router-link-active router-link-exact-active toc-link level2">day07-性能监控工具</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/java/notes/jvm.html#性能监控工具" class="router-link-active router-link-exact-active toc-link level3">性能监控工具</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/java/notes/jvm.html#day08-java堆分析" class="router-link-active router-link-exact-active toc-link level2">day08-java堆分析</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/java/notes/jvm.html#java堆分析" class="router-link-active router-link-exact-active toc-link level3">java堆分析</a></li><!----><!--]--></ul><!--]--></ul></div></aside></div><!----><div class="theme-hope-content"><!--[--><h2 id="总述" tabindex="-1"><a class="header-anchor" href="#总述" aria-hidden="true">#</a> 总述</h2><p>以一个最简单的『Hello world！』的运行实例来说，大概分为这么几个步骤：</p><ol><li>编写阶段：创建一个以『java』为后缀名的文件，并使用编辑器写入代码；</li><li>编译阶段：使用jdk中的javac工具编译java文件，产生.class文件；</li><li>运行阶段： 使用jdk中的java工具运行.class文件，控制台输出『Hello world！』</li></ol><h2 id="编译" tabindex="-1"><a class="header-anchor" href="#编译" aria-hidden="true">#</a> 编译</h2><ul><li>编译器分类</li><li>编译器的优化</li><li>字节码运行方式 <ul><li>解释运行 <ul><li>读一句执行一句</li></ul></li><li>编译运行 <ul><li>先将字节码编译成机器码，运行时直接执行机器码，只在运行时进行编译</li></ul></li><li>对比： 编译后的性能比解释运行的性能有数量级的提升</li></ul></li></ul><h2 id="类的加载" tabindex="-1"><a class="header-anchor" href="#类的加载" aria-hidden="true">#</a> 类的加载</h2><ul><li>加载过程 <ul><li>加载： 从各渠道加载字节码文件，之后生成代表这个类的java.lang.Class对象，作为这个类在方法区各种信息的访问入口；</li><li>链接 <ul><li>验证</li><li>准备</li><li>解析</li></ul></li><li>初始化</li></ul></li><li>双亲委派</li><li>类加载器</li><li>API操作等</li></ul><h2 id="jvm的内存结构" tabindex="-1"><a class="header-anchor" href="#jvm的内存结构" aria-hidden="true">#</a> JVM的内存结构</h2><p>JVM的内存结构可以分为 运行期内存结构 和 GC视角下的内存模型；</p><ul><li>运行期内存结构【存放内容、常见配置参数、异常；】 <ul><li>线程私有 <ul><li>虚拟机栈</li><li>本地方法栈</li><li>程序计数器</li><li>直接内存</li></ul></li><li>线程共享 <ul><li>Java堆</li><li>方法区</li></ul></li><li>对象探秘 <ul><li>对象的内存分布 <ul><li>对象头（包括哈希值、分代次数、持有的锁、偏向线程ID、偏向时间戳）</li><li>实例数据（包括自身属性字段以及从父类继承来的属性字段等）</li><li>对齐填充</li></ul></li><li>对象的创建过程 <ul><li>先进行逃逸分析。判断对象的分配是否需要优化，如栈上分配、标量替换、同步消除等；</li><li>判断能否在方法区的常量池中找到该类的引用。如果没有找到，要先进行类加载过程；</li><li>之后是分配内存。有两种方式，一种是空闲列表，一种是指针碰撞方式。</li><li>处理好同步的问题。</li><li>完成初始化。把对应的字段初始化成相关的零值；</li><li>完成其他剩余信息的构造等。</li></ul></li><li>对象的升代策略</li><li>对象的访问定位 <ul><li>句柄池方式</li><li>直接指针方式</li></ul></li></ul></li></ul></li><li>GC内存模型 <ul><li>eden+s0+s1+old+永久代/元空间</li><li>minorgc、majorgc、FullGC <ul><li>当发现s0空间不足，就会在eden区进行一次YoungGC，把存活对象复制到s0区，如果发现s0区也无法存放，就会出发空间担保机制。</li></ul></li><li>GC日志</li></ul></li></ul><h2 id="jvm中的垃圾回收" tabindex="-1"><a class="header-anchor" href="#jvm中的垃圾回收" aria-hidden="true">#</a> JVM中的垃圾回收</h2><ul><li>存活对象判断标准 <ul><li>引用计数法</li><li>可达性分析 <ul><li>引用类型</li><li>可作为GCRoot的对象</li></ul></li></ul></li><li>垃圾回收算法 <ul><li>标记-清除</li><li>标记-整理</li><li>复制算法</li></ul></li><li>垃圾回收器 <ul><li>分类 <ul><li>Serial <ul><li>单线程回收，回收过程中会暂停所有用户线程，采用的是复制算法，是client模式下默认的收集器</li></ul></li><li>ParallelNew <ul><li>并行执行，采用的也是复制算法，Server模式下的默认收集器，</li></ul></li><li>ParalleScanvenge</li><li>SerialOld</li><li>CMS</li><li>G1</li></ul></li><li>回收过程</li><li>相关的配置参数</li><li>优缺点分析</li><li>实际使用</li></ul></li><li>OOM定位及排查</li></ul><h2 id="jvm中的并发" tabindex="-1"><a class="header-anchor" href="#jvm中的并发" aria-hidden="true">#</a> JVM中的并发</h2><ul><li>JMM模型及其特性、主存与工作内存之间的操作</li><li>线程状态及转化条件</li><li>线程安全（定义、实现方式）</li><li>锁优化方式及原理</li><li>性能优化思路</li></ul><h2 id="实战" tabindex="-1"><a class="header-anchor" href="#实战" aria-hidden="true">#</a> 实战</h2><p>一般情况下，Java应用部署上线时，除了要配置一些运行期内存大小的参数外，还会配置一些用来监控的JVM参数，如gclog、heapDump等。这些监控参数，用来后续生产过程中，遇到问题时的定位，也会用在GC监控，以及后续JVM的调优上。</p><p>根据JVM出现的问题的不同，把所出现的问题大概划归成两部分内容：</p><ol><li>业务异常： 就是JVM运行过程中抛出的一些OOM等异常。</li><li>JVM调优： 这类是可能不会报出具体的错误或异常信息，这类问题大多是由于一些配置参数不合适，导致JVM没有发挥其最大性能。</li></ol><p>所以根据遇到的问题的不同，来采用不同的解决方式。</p><h3 id="业务异常" tabindex="-1"><a class="header-anchor" href="#业务异常" aria-hidden="true">#</a> 业务异常</h3><ul><li>问题表现： 生产环境上，业务突然抛出异常，或者业务无法处理、业务响应超时等；业务日志中会出现异常栈信息；</li><li>问题产生的原因：这类异常大多是由程序员编码不规范而造成的。</li><li>问题解决的关键思路： 找到出现问题的业务代码</li><li>问题定位过程： <ul><li>可以根据业务日志，直接定位到业务代码中；</li><li>也可以分析dump文件；</li></ul></li><li>总结 <ul><li>JVM配置合适的启动参数。如heapDumpOnErrorPath、 heapDumpOnError等；</li><li>建立服务器资源监控及报警机制。如加入链路追踪、集群服务器监控、日志归集、短信电话等报警机制；</li><li>要有严格的开发规范。例如在需求开发过程中，高级程序员或团队老鸟评审菜鸟的实现方案；</li><li>上线前要经过代码Review和严格的测试。代码Review比如记录关键日志、不能查询全表数据、不能循环查数据库、List和Map使用时初始化其大小、IO资源使用完成后要关闭等，严格的测试比如开发人员的单元测试、集成测试、边界值测试等；</li><li>遇到问题时，迅速响应。之后要进行总结，事故分析报告；</li></ul></li></ul><h3 id="jvm调优" tabindex="-1"><a class="header-anchor" href="#jvm调优" aria-hidden="true">#</a> JVM调优</h3><ul><li>结论： 一般情况下，JVM是不需要进行调优的。</li><li>需要调优的场景： <ul><li>经过长期监控后，发现JVM部分指标出现的异常。这些指标多是停顿时间或GC频率。</li><li>部分业务场景需要支持高并发时，要压榨单节点的服务性能。</li></ul></li><li>前置条件： <ul><li>需要建立长效的监控机制。比如接入监控和报警机制、打印GC日志等；</li><li>并完成正常的性能指标的确定。比如一段时间后，什么服务器资源下+什么JVM配置参数下，JVM性能指标【吞吐量、GC日志、停顿时间等】大概是多少；</li><li>监控到异常的性能指标。</li></ul></li><li>问题产生的原因 <ul><li>Java堆设置不合理</li><li>业务较为独特，比如全部都是大对象，对象很快进入老年代；</li></ul></li></ul><h2 id="自己总结的jvm提纲" tabindex="-1"><a class="header-anchor" href="#自己总结的jvm提纲" aria-hidden="true">#</a> 自己总结的JVM提纲</h2><ul><li>编译期分类（前端、后端、解释器、语法糖）</li><li>类的加载器 <ul><li>加载过程</li><li>加载器分类</li><li>类的生命周期</li><li>双亲委派</li></ul></li><li>类的运行 <ul><li>运行期内存结构、每一部分的存放内容、配置参数、出现的异常信息及解决办法</li><li>对象的创建过程、对象的使用、对象的内存分配</li><li>GC分类（FullGC的触发条件）</li></ul></li><li>类的回收 <ul><li>定位垃圾</li><li>GCRoot对象的分类</li><li>四种引用类型</li><li>回收算法</li><li>回收器分类 <ul><li>各自的原理</li><li>配置的参数</li><li>优缺点</li></ul></li><li>安全点及全局停顿</li></ul></li><li>JVM中的并发 <ul><li>JMM模型及其特性、主存与工作内存之间的操作</li><li>线程状态及转化条件</li><li>线程安全（定义、实现方式）</li><li>锁优化方式及原理</li><li>性能优化思路</li></ul></li></ul><h2 id="思考题" tabindex="-1"><a class="header-anchor" href="#思考题" aria-hidden="true">#</a> 思考题</h2><blockquote><p>哔站上：炼数成金 深入理解JVM 葛一鸣</p></blockquote><p>day01 在未来Java应该增加和支持那些功能呢？</p><p>day03</p><ol><li>jre的运行时主要jar文件rt.jar都很大，这导致了用java做的桌面客户端程序很难发布绑定jre发布。这在很大程度上限制了java桌面软件的分发。可是，jre并不是在所有的用户计算机上都有安装，即使安装了，也未必我们期望的版本。因此，对jre做精简，减少体积是有必要的。请你给出一个方案，来说说如何给jre减肥，以方便我们的桌面程序绑定jre发布。并给出一个基本的实现。对这个实现的要求是：对于任意给定java程序A，应用你的方案和实现，可以从一个完整的jre中，抽取这个程序A的必要部分，从而实现最小体积的发布。在本题中，要求你详述你的方案，并提交你实现的代码。</li></ol><p>2.这里给出一个gc输出，要求给出一个你认为最可能的启动JVM参数，并说明为什么？ Heap def new generation total 6464K, used 115K [0x34e80000, 0x35580000, 0x35580000) eden space 5760K, 2% used [0x34e80000, 0x34e9cd38, 0x35420000) from space 704K, 0% used [0x354d0000, 0x354d0000, 0x35580000) to space 704K, 0% used [0x35420000, 0x35420000, 0x354d0000) tenured generation total 18124K, used 8277K [0x35580000, 0x36733000, 0x37680000) the space 18124K, 45% used [0x35580000, 0x35d95758, 0x35d95800, 0x36733000) compacting perm gen total 16384K, used 16383K [0x37680000, 0x38680000, 0x38680000) the space 16384K, 99% used [0x37680000, 0x3867ffc0, 0x38680000, 0x38680000) ro space 10240K, 44% used [0x38680000, 0x38af73f0, 0x38af7400, 0x39080000) rw space 12288K, 52% used [0x39080000, 0x396cdd28, 0x396cde00, 0x39c80000)</p><p>day04</p><ol><li>标记压缩对标记清除有什么优势？</li></ol><p>day05</p><ol><li>为了解决GC压力，我们需要注意些什么？ 软件系统如何设计架构、代码如何编写、堆空间如何分配等</li></ol><p>day06</p><ol><li>java.lang.NoSuchFieldError错误可能在什么阶段抛出？</li><li>能否只使用反射，将类注入启动ClassLoader中呢？</li><li>java框架rt.jar是如何加载应用的类？ rt.jar中的启动加载器是无法加载应用程序的类的，这就是 Thread.setContextClassLoader()</li></ol><ul><li>上下文加载器</li><li>是一个角色，并不指定某一个具体的启动器类</li><li>用以解决顶层ClassLoader无法访问底层ClassLoader的类的问题</li><li>基本思想是，在顶层的ClassLoader中，注入底层的ClassLoader的实例</li></ul><ol start="4"><li>如何实现热替换？</li></ol><p>day07</p><ol><li>找到系统中最消耗cpu资源的进程。</li></ol><h2 id="day01-初识jvm" tabindex="-1"><a class="header-anchor" href="#day01-初识jvm" aria-hidden="true">#</a> day01-初识JVM</h2><h3 id="jvm的概念" tabindex="-1"><a class="header-anchor" href="#jvm的概念" aria-hidden="true">#</a> jvm的概念</h3><pre><code>Java虚拟机
虚拟机：通过软件模拟的具有完整硬件系统的功能的、运行在一个完全隔离环境中的完整计算机系统

vmware和visual box都是使用软件模拟物理cpu的指令
jvm主要是通过软件模拟Java字节码的指令集
</code></pre><h3 id="jvm发展历史" tabindex="-1"><a class="header-anchor" href="#jvm发展历史" aria-hidden="true">#</a> jvm发展历史</h3><pre><code>1996年 jdk1.0 classic vm 纯解释运行，使用外挂进行jit
97年 jdk1.1 awt 内部类、jdbc、rmi、反射
98年 jdk1.2 solaris exact vm
2000年 jdk1.3 hotspot 作为默认虚拟机
02年，jdk1.4 classic vm 退出历史舞台
04年 jdk1.5 泛型、注解、装箱拆箱、枚举、可变长的参数、foreach
jdk1.6 脚本语言支持、jdbc4.0、Java编译器api
11年 jdk7 发布
14年 jdk8 发布 lambda表达式，语法增强、Java类型注解
16年jdk9 模块化

大事记：
	hotspot最火
	06年开源并建立openjdk
	08年oracle收购bea得到jrockitvm
	10年oracle收购sun得到hotspot
	oracle宣布在jdk8时整合jrockit和hotspot，优势互补（在hotspot基础上移植jrockit优秀特性）
</code></pre><h3 id="jvm种类" tabindex="-1"><a class="header-anchor" href="#jvm种类" aria-hidden="true">#</a> jvm种类</h3><p>略。</p><h3 id="java语言规范" tabindex="-1"><a class="header-anchor" href="#java语言规范" aria-hidden="true">#</a> java语言规范</h3><pre><code>定义了语法、变量、类型、文法
语法定义、词法结构、类型和变量、Java内存模型、类加载链接的国恒、关键字的定义、异常、数组的使用……
</code></pre><h3 id="jvm规范" tabindex="-1"><a class="header-anchor" href="#jvm规范" aria-hidden="true">#</a> jvm规范</h3><pre><code>class文件类型、运行时数据、帧栈、虚拟机的启动、虚拟机的指令集、堆、PC、方法区……
什么是java虚拟机

整数的表达：
	原码：第一位为符号为（0正1负）
	反码：符号位不动，原码取反
	负数补码：符号位不动，反码+1
	正数补码：和原码相同

为什么要使用补码？
	计算机中0有两种方式，正0和负0，使用补码的时候，就只有一种表示方法了。

float的表示和定义IEEE 754 标准
	符号位+指数位+尾数位

vm指令集
	类型转换、出栈入栈操作、原酸、流程控制、函数控制

jvm需要堆java library提供以下支持：
	反射、classloader、初始化class和interface、安全相关、多线程、弱引用

jvm的编译
	源码到jvm指令的对应格式
	javap
	jvm反汇编的格式
</code></pre><h2 id="day02-jvm运行机制" tabindex="-1"><a class="header-anchor" href="#day02-jvm运行机制" aria-hidden="true">#</a> day02-JVM运行机制</h2><h3 id="jvm的启动流程" tabindex="-1"><a class="header-anchor" href="#jvm的启动流程" aria-hidden="true">#</a> jvm的启动流程</h3><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>装载配置-根据配置找jvm.dll文件-初始化jvm获取到JNIEnv接口-找到main方法，并运行
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><h3 id="jvm的基本结构" tabindex="-1"><a class="header-anchor" href="#jvm的基本结构" aria-hidden="true">#</a> jvm的基本结构</h3><pre><code>主要关注的时内存空间的分配和回收
PC寄存器
	- 一个线程独占一个pc寄存器
	- 线程创建时创建
	- 存放的是下一条要执行的指令的地址
	- 执行本地方法时，PC寄存器存放的内容为undefined
方法区
	- 保存类的元信息（常量池、字段、方法信息、方法字节码等）
	- 通常和永久区（perm）关联在一起
	- 跟jdk的版本有关
Java堆
	- 和程序开发最密切相关的区域
	- 应用系统对象基本上都是保存在java堆上面
	- 所有线程共享Java堆
	- 对分代GC来说，堆也是分代的
	- 不同的GC算法，对应的也是不同的堆
Java栈
	- 线程私有
	- 栈由一系列帧组成的
	- 帧保存一个方法的局部变量、操作数栈、常量池指针
	- 每一个方法调用都会创建一个帧，并压栈（栈：先进后出）
	- 局部变量表（包括参数和局部变量）
	- 函数调用组成栈帧
	- 操作数栈：java中没有寄存器的概念，所有的参数传递都使用操作数栈
	- 栈上分配：
		一般是小对象（几十个bytes），大对象或逃逸对象是没有办法在栈上分配的，在没有逃逸的情况下是可以直接分配到栈上的，这样做的好处是可以自动回收，减轻gc压力；
	- 逃逸分析：
		逃逸分析的基本行为就是分析对象动态作用域，当一个对象在方法中被定义后，可能会被外部方法所引用，比如方法调用，也有可能被其他线程访问，比如类变量，这两种情况分别叫做对象的方法逃逸和线程逃逸
本地方法栈

栈、堆、方法区交互
	可以根据具体的程序来分析，主要描述程序代码的存储位置以及运行流程
</code></pre><h3 id="jvm的内存模型" tabindex="-1"><a class="header-anchor" href="#jvm的内存模型" aria-hidden="true">#</a> jvm的内存模型</h3><pre><code>- 每一个线程都有一个工作内存和主内存
- 工作内存存放主存中变量的值的拷贝

- 可见性
	一个线程修改了变量，其他线程可以立即知道

	产生变量不可见的原因：
		每一个线程都有自己的主存区域和线程工作内存区域，线程在使用变量时，会先把存放到主存中的变量load到线程工作内存区域，这就导致了一个线程修改变量时，另外一个线程没办法同时共享该变量，导致了变量的暂时不可见性。

	保持变量可见性的方法：
		- volatile 关键字
		- synchronized （unlock之前，写变量值到主存中）
		- final（一旦初始化之后，其他线程就可见）

- 有序性
	操作指令的顺序在本线程内时有序的，但是在本线程外是无序的（因为发生了指令重排或主内存与工作内存同步延时）。

	指令重排-容易破坏线程间的指令有序性
	保证线程之间的指令有序性的方法：使用synchronized关键字，使线程互斥运行，人为保证指令的有序性。

	指令重排的原则：
		- 线程内保证语义的串行性
		- volatile规则： volatile变量的写，先发生于读
		- 锁规则：解锁必然要发生在另外线程的加锁前
		- 传递性： a先于b，b先于c，那a必然先于c
		- 线程的start方法先于其他所有的动作
		- 线程所有的操作先于线程的终结
		- 线程的中断先于中断后要执行的代码
		- 构造方法先于finalize（）方法
</code></pre><h3 id="编译运行和解释运行的区别" tabindex="-1"><a class="header-anchor" href="#编译运行和解释运行的区别" aria-hidden="true">#</a> 编译运行和解释运行的区别</h3><pre><code>- 这是字节码运行的两种方式：
- 解释运行
	- 读一句执行一句
- 编译运行
	- 先将字节码编译成机器码，运行时直接执行机器码，只在运行时进行编译
	编译后的性能比解释运行的性能有数量级的提升
</code></pre><h2 id="day03-常用jvm配置参数" tabindex="-1"><a class="header-anchor" href="#day03-常用jvm配置参数" aria-hidden="true">#</a> day03-常用JVM配置参数</h2><p>https://www.cnblogs.com/qlqwjy/p/8037797.html https://www.cnblogs.com/cat520/p/9958475.html https://blog.csdn.net/yang_net/article/details/5830820 -XX:+<code>&lt;option&gt;</code> 启用option，例如：-XX:+PrintGCDetails启动打印GC信息的选项，其中+号表示true，开启的意思 -XX:-<code>&lt;option&gt;</code> 不启用option，例如：-XX:-PrintGCDetails关闭启动打印GC信息的选项，其中-号表示false，关闭的意思 -XX:<code>&lt;option&gt;</code>=<code>&lt;number&gt;</code> 设定option的值为数字类型，可跟单位，例如 32k, 1024m, 2g。例如：-XX:MaxPermSize=64m -XX:<code>&lt;option&gt;</code>=<code>&lt;string&gt;</code> 设定option的值为字符串，例如： -XX:HeapDumpPath=&quot;C:\Users\Daxin\Desktop\jvmgcin&quot;</p><p>但是有的参数不需要使用-XX，例如：-Xms， -Xmx ，-Xmn ，-Xss</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>
常用配置参数
- trace跟踪参数
	# -vervose:gc
	# -XX:+printGC
	# -XX:+PrintGCDetails
		会打印gc详细信息
		GC后打印
	# -XX:+PrintGCTimeStamps
		会打印GC发生的时间戳
	# -Xloggc:log/gc.log
		指定GClog的位置，以文件输出
	# -XX:+PrintHeapAtGC
		每一次GC后，都打印堆信息
	# -XX:+TraceClassLoading
		监控类的加载
	# -XX:+PrintClassHistogram
		按下Ctrl+Break后，打印类的信息
		分别显示：序号、实例数量、总大小、类型

- 堆的分配参数
	# -Xmx
		最大堆		
	# -Xms
		最小堆
	Runtime.getRuntime().maxMemory()/1024/1024 兆
	Runtime.getRuntime().freeMemory()/1024/1024 兆
	Runtime.getRuntime().totalMemory()/1024/1024 兆

	jvm会将堆的大小尽量维持在最小堆的范围内，如果在经过了gc之后，最小堆还不能满足需求，就会进行扩容。

	思考问题：
		1. 最大堆和最小堆应该保持一个什么关系，才能让系统的性能尽可能的好呢？

		2. 如果要做一个Java桌面产品，需要绑定jre，但是jre又很大，如何做jre的瘦身呢？


	# -Xmn
		设置新生代大小
	# -XX:NewRatio
		新生代（eden+2*s，eden区加上两个幸存区）和老年代（不包括永久区）的比值
		4 表示 新生代：老年代=1：4，即年轻代占堆的1/5
	# -XX:SurvivorRatio
		设置两个Survivor区的eden的比
		8表示两个survivor：eden=2：8，即一个survivor占年轻代的1/10
	# -XX:+HeapDumpOnOutOfMemoryError
		oom时导出堆到文件
	# -XX:+HeapDumpPath
		导出oom的路径
	# -XX:OnOutOfMemoryError
		在oom时，执行一个脚本，一般常用来oom时，发送邮件甚至重启程序等。
	需要实际调整新生代和幸存代的大小，官方推荐新生代占堆的3/8，幸存代占新生代的1/10，在oom时，要dump出堆，确保可以排查现场问题。

永久区分配参数
	# -XX:PermSize -XX:MaxPermSize
		设置永久区的初始空间和最大空间，一个系统可以容纳多少个类型

- 栈的分配参数
	# -Xss
		通常只有几百k
		决定了函数调用的深度（递归调用时的深度）
		每一个线程都有独立的栈空间，因此要想使系统能够尽可能多的使用线程，就只能减少栈的大小
		局部变量、参数都分配到栈上

		java.lang.StackOverflowError错误一般时因为方法调用出了问题

</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br></div></div><h2 id="day04-gc算法和种类" tabindex="-1"><a class="header-anchor" href="#day04-gc算法和种类" aria-hidden="true">#</a> day04-GC算法和种类</h2><h3 id="gc的概念" tabindex="-1"><a class="header-anchor" href="#gc的概念" aria-hidden="true">#</a> GC的概念</h3><pre><code>垃圾回收，主要用来解决由程序引起的内存泄露等问题，GC的对象是堆空间和永久区
</code></pre><h3 id="gc的算法" tabindex="-1"><a class="header-anchor" href="#gc的算法" aria-hidden="true">#</a> GC的算法</h3><pre><code>- 引用计数法
	老牌垃圾回收算法，通过引用计算来回收垃圾，使用者：COM、ActionScript3、Python
	问题：引用和去引用都伴随着加法和减法，影响性能；很难处理循环引用的垃圾对象

	【在Java中并没有使用这种算法】

- 标记清除【老年代回收算法】
	分为标记阶段和清除阶段。从根节点开始，标记所有可达的对象，未被标记的对象就是未被引用的垃圾对象，然后是清除阶段，清除所有未被标记的对象。

- 标记压缩【老年代回收算法】
	适合存活对象比较多的场合，如老年代。也是从根节点开始，对所有可达对象做一次标记，然后将标记对象压缩到内存的一端，之后，清理边界外的所有空间


- 复制算法【新生代回收算法】
	比较高效的回收方法，不适合存活对象较多的场合，如老年代。将内存区域分为两块，每次只使用其中的一块，在垃圾回收时，将正在使用的内存中的存活对象复制到未使用的内存中，之后，清除正在使用的内存块中的所有对象，交换两个内存的角色，完成回收。
	最大的问题就是空间浪费、整合标记清除的思想
	三个存储空间和一个担保空间【复制算法+标记清理的算法】

	-XX:+PrintGCDetails的输出中的eden和from、to等就是标记复制算法的三块区域

	分代思想：
	短命对象为新生代，长命对象为老年代

	少量对象存活，使用复制算法；
	大量对象存活，使用标记清理或标记压缩算法等；

【总结】
所有的算法，都需要识别一个对象是否为垃圾对象，因此需要给出什么是垃圾对象的定义。即什么是可触及性？
</code></pre><h3 id="可触及性" tabindex="-1"><a class="header-anchor" href="#可触及性" aria-hidden="true">#</a> 可触及性</h3><pre><code>- 可触及的
	从根节点可以触及到这个对象
- 可复活的
	暂时没有被触及，但是后期又被触及的对象
	可能会在finalize()中可能复活对象
- 不可触及的
	在finalize()后，可能进入不可触及状态，可以回收
	finalize()只能被执行一次，避免使用该方法，优先级太低，不确定何时被调用，可以使用try catch finally等来代替

- 根
	栈中引用的对象，即线程栈中引用的对象
	方法区中静态成员或常量引用的对象（即全局对象）
	jni方法栈中引用的对象
</code></pre><h3 id="stop-the-world" tabindex="-1"><a class="header-anchor" href="#stop-the-world" aria-hidden="true">#</a> stop-the-world</h3><pre><code>java中一种全局暂停的现象，所有java代码停止，native代码可以执行，但是不能和jvm交互。可以理解为整个jvm处于挂起状态。
多半是由于GC引起
	dump线程时
	死锁检查
	堆dump时

为什么gc会产生全局停顿？
	类比于聚会时打扫房间，聚会时会很乱，又会有新的垃圾产生，房间永远打扫不干净，只有让大家停止活动了，才能将房间打扫干净。
	GC线程启动时，所有的应用线程都会停止。
会有什么危害？
	长时间服务停止，没有响应。
	遇到ha系统，可能会引起主备切换，严重危害生产系统
</code></pre><h2 id="day05-gc参数" tabindex="-1"><a class="header-anchor" href="#day05-gc参数" aria-hidden="true">#</a> day05-GC参数</h2><h3 id="堆的回顾" tabindex="-1"><a class="header-anchor" href="#堆的回顾" aria-hidden="true">#</a> 堆的回顾</h3><pre><code>新生代（eden+s0(或者from区)+s1（或者to区））+老年代（tenured）
</code></pre><h3 id="串行收集器" tabindex="-1"><a class="header-anchor" href="#串行收集器" aria-hidden="true">#</a> 串行收集器</h3><pre><code>最古老的、也是最稳定的的收集器、效率高，可能会产生很长的停顿，历经考验

可以使用-XX:+UseSerialGC参数开启，
开启之后，新生代和老年代都使用串行回收、新生代使用的是复制算法、老年代使用的是标记-压缩算法

在回收时，应用程序线程会暂停，垃圾回收器线程会启动，只是用一个线程回收，回收完毕之后，应用程序线程再次启动
</code></pre><h3 id="并行收集器" tabindex="-1"><a class="header-anchor" href="#并行收集器" aria-hidden="true">#</a> 并行收集器</h3><pre><code>parnew收集器
	使用 -XX:+UseParNewGC 参数开启，
	新生代并行回收、老年代串行回收
	复制算法
	多线程回收，需要多核支持
	使用 -XX:ParallelGCThreads限制线程数量
	serial收集器新生代的并行版本

	在回收时，应用程序县城依然会暂停，只不过此时垃圾回收器线程是多个，回收完毕之后，应用程序线程再次启动。

Parallel收集器
	类似于parnew收集器
	可以看作是串行收集器在新生代和老年代的并行化
	新生代复制算法
	老年代标记-压缩算法
	更加关注吞吐量的一类算法
	使用-XX:+UseParallelGC（使用parallel收集器+老年代串行）
	使用-XX:+UseParallelOldGC（使用parallel收集器+并行老年代）

参数：
	-XX:MaxGCPauseMills（最大停顿时间、毫秒，GC尽力保证回收的时间不超过这个设定值）
	-XX:GCTimeRatio（垃圾收集时间占总时间的比值，默认99，即最大允许1%的时间做GC）

	两个参数可以看作是一个用来调GC的频率，一个用来调每次GC的时间，当然这种看法是不够准确的。在系统中，在相同环境下，如果要保证每次垃圾回收系统停顿的时间很短，那必然就需要经常进行GC，换句话也就是要加大GC的次数；相反，如果要使的GC占用时间比值加大，就会使频率降低，二者属于相互矛盾的。
</code></pre><h3 id="cms收集器" tabindex="-1"><a class="header-anchor" href="#cms收集器" aria-hidden="true">#</a> CMS收集器</h3><pre><code>Concurrent Mark Sweep 并发标记清除
标记清除算法
不是标记压缩算法
并发阶段会降低吞吐量（并发阶段，垃圾回收器可能会造成资源浪费，也就造成吞吐量的减少）
老年代收集器（新生代使用ParNew）
使用-XX:+UseConcMarkSweepGC

并发是指：与应用程序线程一并执行的。

CMS运行过程是复杂的，着重实现了标记的过程，可分为：
	- 初始标记
		标记线程是独占的，这个阶段只有标记线程在运行
		根可以直接关联到的对象
		速度快
	- 并发标记（和应用程序线程一起）
		主要标记过程，标记全部对象		
	- 重新标记
		由于并发标记时，用户线程依然在运行，因此在进行清理时，再次修正
	- 并发清理
		基于标记结果，进行清理对象

	- 并发重置

特点
	尽可能减低停顿
	会影响系统整体吞吐量和性能
		应用程序线程再运行过程中，分一半的CPU资源去做GC，系统性能在GC阶段，反应速度就会下降一半。
	清理不彻底
	因为和应用程序线程一起运行，不能再空间快满时再清理
		使用-XX:CMSInitiatingOccupancyFraction设置触发GC的阈值
		如果预留空间不够，可能会引起concurrent mode failure错误（原因是：在进行垃圾回收时，应用程序线程依然申请内存资源，就可能导致申请不到资源，出现错误。解决方案：使用串行垃圾回收）

	-XX:+UseCMSCompactAtFullCollection 在full gc后，进行一次整理，在整理过程时线程独占的，会引起停顿时间变长

	-XX:+CMSFullGCsBeforeCompaction 在进行多次full gc后，进行一次碎片整理

	-XX:ParallelCMSThreads 设置CMS的线程数量

标记清除和标记压缩算法
	标记清除算法会产生碎片，碎片会影响后续的内存分配

分析：cms收集器主要是为了解决停顿时间很长的问题而产生的，但是它实际上并没有很好的解决停顿时间，它只是换了一种方式来实现标记而已，也就是说它的目标转移到标记上了。
</code></pre><h3 id="gc参数整理" tabindex="-1"><a class="header-anchor" href="#gc参数整理" aria-hidden="true">#</a> GC参数整理</h3><pre><code>-XX:+UseSerialGC：在新生代和老年代使用串行收集器
-XX:SurvivorRatio：设置eden区大小和survivior区大小的比例
-XX:NewRatio:新生代和老年代的比
-XX:+UseParNewGC：在新生代使用并行收集器
-XX:+UseParallelGC ：新生代使用并行回收收集器
-XX:+UseParallelOldGC：老年代使用并行回收收集器
-XX:ParallelGCThreads：设置用于垃圾回收的线程数
-XX:+UseConcMarkSweepGC：新生代使用并行收集器，老年代使用CMS+串行收集器
-XX:ParallelCMSThreads：设定CMS的线程数量
-XX:CMSInitiatingOccupancyFraction：设置CMS收集器在老年代空间被使用多少后触发
-XX:+UseCMSCompactAtFullCollection：设置CMS收集器在完成垃圾收集后是否要进行一次内存碎片的整理
-XX:CMSFullGCsBeforeCompaction：设定进行多少次CMS垃圾回收后，进行一次内存压缩
-XX:+CMSClassUnloadingEnabled：允许对类元数据进行回收
-XX:CMSInitiatingPermOccupancyFraction：当永久区占用率达到这一百分比时，启动CMS回收
-XX:UseCMSInitiatingOccupancyOnly：表示只在到达阀值的时候，才进行CMS回收
</code></pre><h3 id="tomcat实例演示" tabindex="-1"><a class="header-anchor" href="#tomcat实例演示" aria-hidden="true">#</a> Tomcat实例演示</h3><h3 id="full-gc-和-minor-gc的区别" tabindex="-1"><a class="header-anchor" href="#full-gc-和-minor-gc的区别" aria-hidden="true">#</a> full GC 和 minor GC的区别</h3><h2 id="day06-类加载器" tabindex="-1"><a class="header-anchor" href="#day06-类加载器" aria-hidden="true">#</a> day06-类加载器</h2><h3 id="class装载验证流程" tabindex="-1"><a class="header-anchor" href="#class装载验证流程" aria-hidden="true">#</a> class装载验证流程</h3><h4 id="流程" tabindex="-1"><a class="header-anchor" href="#流程" aria-hidden="true">#</a> 流程</h4><ul><li><p>加载</p><pre><code>  装载类的第一个阶段
  取得类的二进制流
  转为方法区的数据结构
  在Java堆中生成对应的java.lang.Class对象
</code></pre></li><li><p>链接 验证 - 目的：验证class流的格式是否是正确的 - 文件格式的验证 - 元数据的验证 - 字节码验证（很复杂） - 符号引用验证 准备 - 分配内存，并为类设置初始值（方法区中）</p><pre><code>  解析
  	- 符号引用替换为直接引用
</code></pre></li><li><p>初始化 - 执行类构造器（clinit） - static变量 赋值语句 - static{}语句 - 子类的（clinit）调用之前先调用父类的（clinit） - clinit是线程安全的</p></li></ul><h3 id="什么是类装载器classloader" tabindex="-1"><a class="header-anchor" href="#什么是类装载器classloader" aria-hidden="true">#</a> 什么是类装载器ClassLoader</h3><pre><code>是一个抽象类
它的实例将Java字节码装载到jvm中
可以定制，满足不同的字节码流获取方式
负责装载过程的加载过程
</code></pre><h3 id="jdk中classloader默认设计模式" tabindex="-1"><a class="header-anchor" href="#jdk中classloader默认设计模式" aria-hidden="true">#</a> jdk中ClassLoader默认设计模式</h3><pre><code>classLoader的重要方法
不同的ClassLoader
	- 启动ClassLoader （Bootstrap ClassLoader） rt.jar /-Xbootclasspath
	- 扩展ClassLoader（Extension ClassLoader） %JAVA_HOME%/lib/ext/*.jar
	- 应用ClassLoader（App ClassLoader） claspath下
	- 自定义ClassLoader（Custom ClassLoader）

	- 每一个ClassLoader都有一个Parent作为父类

	在查找一个类是否加载时，应用程序会依次调用AppClassLoader、ExtensionClassLoader、BootstrapClassLoader去查找类是否加载的。但是在加载过程则是依次使用BootstrapClassLoader、ExtensionClassLoader、AppClassLoader来依次加载应用程序所需要的类。
</code></pre><ul><li>双亲模式的破坏 <ul><li>双亲模式是默认的模式，但是不是必须这么做</li><li>Tomcat的webAPPClassLoad而就会先加载自己的class，找不到再委托parent</li><li>OSGI的classLoader形成网状结构，根据需要自由的加载Class</li></ul></li></ul><h3 id="打破常规模式" tabindex="-1"><a class="header-anchor" href="#打破常规模式" aria-hidden="true">#</a> 打破常规模式</h3><h3 id="热替换" tabindex="-1"><a class="header-anchor" href="#热替换" aria-hidden="true">#</a> 热替换</h3><p>https://blog.csdn.net/weixin_38055381/article/details/81382115 https://www.cnblogs.com/xxbcoder/p/5112632.html</p><h2 id="day07-性能监控工具" tabindex="-1"><a class="header-anchor" href="#day07-性能监控工具" aria-hidden="true">#</a> day07-性能监控工具</h2><h3 id="性能监控工具" tabindex="-1"><a class="header-anchor" href="#性能监控工具" aria-hidden="true">#</a> 性能监控工具</h3><ul><li><p>系统性能监控</p><ul><li>确定系统运行的整体状态，基本定位问题所在</li><li>Linux平台下 <ul><li>uptime：用于查看系统时间、运行时间、连接数、（1，5,15分钟内的系统平均负载，即运行队列中的平均进程数）</li><li>top：可以知道哪一个程序占用cpu最多</li><li>vmstat：可以统计系统的CPU、内存、swap、io等情况</li><li>pidstat <ul><li>需要安装 sudo apt-get install sysstat</li><li>可以细致观察进程</li><li>监控cpu、io、内存</li><li>使用方法</li></ul></li></ul></li><li>windows平台下 <ul><li>任务管理器</li><li>性能监控器</li><li>Process Explorer</li><li>pslist <ul><li>命令行工具</li><li>自动化数据收集</li><li>显示java程序的运行情况</li></ul></li></ul></li></ul></li><li><p>java自带的工具</p><ul><li>查看java程序运行细节，进一步定位问题</li><li>jps <ul><li>列出java进程，类似于ps命令</li><li>参数-q可以指定jps只输出进程ID ，不输出类的短名称</li><li>参数-m可以用于输出传递给Java进程（主函数）的参数</li><li>参数-l可以用于输出主函数的完整路径</li><li>参数-v可以显示传递给JVM的参数</li></ul></li><li>jinfo <ul><li>可以用来查看正在运行的Java应用程序的扩展参数，甚至支持在运行时，修改部分参数</li><li>-flag <code>&lt;name&gt;</code>：打印指定JVM的参数值</li><li>-flag [+|-]<code>&lt;name&gt;</code>：设置指定JVM参数的布尔值</li><li>-flag <code>&lt;name&gt;</code>=<code>&lt;value&gt;</code>：设置指定JVM参数的值</li></ul></li><li>jmap <ul><li>生成Java应用程序的堆快照和对象的统计信息</li></ul></li><li>jstack <ul><li>打印线程dump</li></ul></li><li>JConsole <ul><li>图形化监控工具</li><li>可以查看Java应用程序的运行概况，监控堆信息、永久区使用情况、类加载情况等</li></ul></li><li>Visual VM <ul><li>一个功能强大的多合一故障诊断和性能监控的可视化工具</li></ul></li></ul></li><li><p>实战分析</p><ul><li>案例分析</li></ul></li></ul><h2 id="day08-java堆分析" tabindex="-1"><a class="header-anchor" href="#day08-java堆分析" aria-hidden="true">#</a> day08-java堆分析</h2><h3 id="java堆分析" tabindex="-1"><a class="header-anchor" href="#java堆分析" aria-hidden="true">#</a> java堆分析</h3><ul><li><p>内存溢出（OOM）的原因</p></li><li><p>MAT使用基础</p></li><li><p>使用VisualVM分析堆</p></li><li><p>tomcatOOM分析案例</p></li></ul><hr><p><br><br><br><img style="border:1px red solid;display:block;margin:0 auto;" src="https://tianqingxiaozhu.oss-cn-shenzhen.aliyuncs.com/img/qrcode.jpg" alt="微信公众号"></p><!--]--></div><!----><footer class="page-meta"><div class="meta-item edit-link"><a href="https://github.com/zeanzai/zeanzai.github.io/edit/main/docs/java/notes/jvm.md" rel="noopener noreferrer" target="_blank" aria-label="编辑此页" class="nav-link label"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewbox="0 0 1024 1024" aria-labelledby="edit"><title id="edit" lang="en">edit icon</title><g fill="currentColor"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></g></svg><!--]-->编辑此页<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="meta-item update-time"><span class="label">上次编辑于: </span><span class="info">2023/8/17 04:43:51</span></div><div class="meta-item contributors"><span class="label">贡献者: </span><!--[--><!--[--><span class="contributor" title="email: zeanzai.me@gmail.com">zeanzai</span><!--]--><!--]--></div></footer><nav class="page-nav"><a href="/java/notes/c2c.html" class="nav-link prev" aria-label="《C2C 电商系统微服务架构 120 天实战训练营》"><div class="hint"><span class="arrow left"></span>上一页</div><div class="link"><!---->《C2C 电商系统微服务架构 120 天实战训练营》</div></a><a href="/java/notes/redis.html" class="nav-link next" aria-label="《Redis 核心原理与实战》"><div class="hint">下一页<span class="arrow right"></span></div><div class="link">《Redis 核心原理与实战》<!----></div></a></nav><div class="giscus-wrapper input-top" style="display:block;"><giscus-widget repo="zeanzai/zeanzai.github.io" repoId="R_kgDOI84HVQ" category="Announcements" categoryId="DIC_kwDOI84HVc4CUKFF" lang="zh-CN" theme="light" mapping="pathname" inputPosition="top" reactionsEnabled="1" emitMetadata="0"></giscus-widget></div><!----></main><!--]--><footer class="footer-wrapper"><div class="footer">浪漫骑士的二流键盘</div><div class="copyright">Copyright © 2023 天晴小猪</div></footer></div><!--]--><!----><!--]--></div>
    <script type="module" src="/assets/app.77a131fa.js" defer></script>
  </body>
</html>
