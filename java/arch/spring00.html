<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-beta.38" />
    <meta name="theme" content="VuePress Theme Hope" />
    <meta property="og:url" content="https://zeanzai.me/java/arch/spring00.html"><meta property="og:site_name" content="天晴小猪"><meta property="og:title" content="Spring基本原理"><meta property="og:type" content="article"><meta property="og:updated_time" content="2023-10-23T00:44:48.000Z"><meta property="og:locale" content="zh-CN"><meta property="article:tag" content="spring"><meta property="article:modified_time" content="2023-10-23T00:44:48.000Z"><link rel="stylesheet" href="//at.alicdn.com/t/font_2410206_mfj6e1vbwo.css"><title>Spring基本原理 | 天晴小猪</title><meta name="description" content="天晴小猪 | 关于后端与架构设计 | Software Engineer | Backend | JAVA | DevOps | Linux | IDEA | Microservice | 我活在世上，无非想要明白些道理，遇见些有趣的事。倘能如我所愿，我的一生就算成功。">
    <style>
      :root {
        --bg-color: #fff;
      }

      html[data-theme="dark"] {
        --bg-color: #1d2025;
      }

      html,
      body {
        background-color: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.querySelector("html").setAttribute("data-theme", "dark");
      }
    </script>
    <link rel="stylesheet" href="/assets/style.fac109b7.css">
    <link rel="modulepreload" href="/assets/app.42286db3.js"><link rel="modulepreload" href="/assets/spring00.html.7f622632.js"><link rel="modulepreload" href="/assets/spring00.html.3ad0c10f.js"><link rel="modulepreload" href="/assets/plugin-vue_export-helper.21dcd24c.js">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="skip-link sr-only">Skip to content</a><!--]--><div class="theme-container has-toc sidebar-open"><!--[--><header class="navbar"><button class="toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><a href="/" class="home-link"><img class="logo" src="/logo.JPG" alt="天晴小猪"><!----><span class="site-name hide-in-pad">天晴小猪</span><!--[--><!----><!--]--></a><nav class="nav-links" style=""><div class="nav-item hide-in-mobile"><a href="/java/" class="nav-link active" aria-label="Java面试宝典"><i class="icon iconfont icon-java"></i>Java面试宝典<!----></a></div><div class="nav-item hide-in-mobile"><a href="/springcloud-alibaba/" class="nav-link" aria-label="SpringCloud-Alibaba实战"><i class="icon iconfont icon-code"></i>SpringCloud-Alibaba实战<!----></a></div><div class="nav-item hide-in-mobile"><a href="/question/" class="nav-link" aria-label="面试自查宝典"><i class="icon iconfont icon-quote"></i>面试自查宝典<!----></a></div><div class="nav-item hide-in-mobile"><a href="/linux/" class="nav-link" aria-label="开发环境手册"><i class="icon iconfont icon-customize"></i>开发环境手册<!----></a></div><div class="nav-item hide-in-mobile"><a href="/slashteen/" class="nav-link" aria-label="副业之路"><i class="icon iconfont icon-java"></i>副业之路<!----></a></div></nav><div class="nav-actions-wrapper"><!--[--><!----><!--]--><div class="nav-item"><!----></div><div class="nav-item"><a class="repo-link" href="https://github.com/zeanzai/zeanzai.github.io" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewbox="0 0 1024 1024" aria-labelledby="github" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><title id="github" lang="en">github icon</title><g fill="currentColor"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></g></svg></a></div><div class="nav-item hide-in-mobile"><button id="appearance-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewbox="0 0 1024 1024" aria-labelledby="auto" style="display:block;"><title id="auto" lang="en">auto icon</title><g fill="currentColor"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></g></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewbox="0 0 1024 1024" aria-labelledby="dark" style="display:none;"><title id="dark" lang="en">dark icon</title><g fill="currentColor"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></g></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewbox="0 0 1024 1024" aria-labelledby="light" style="display:none;"><title id="light" lang="en">light icon</title><g fill="currentColor"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></g></svg></button></div><!----><button class="toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span class="button-container"><span class="button-top"></span><span class="button-middle"></span><span class="button-bottom"></span></span></button><!--[--><!----><!--]--></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow left"></span></div><aside class="sidebar"><!--[--><!----><!--]--><ul class="sidebar-links"><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">零、面试前准备</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">一、计算机基础</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">二、JavaCore</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">三、框架</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">四、中间件</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">五、分布式</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">六、源码系列</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">七、项目实战</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">八、学习笔记</span><span class="arrow right"></span></button><!----></section><!--]--></li><li><!--[--><section class="sidebar-group"><button class="sidebar-heading clickable"><!----><span class="title">九、工作技巧</span><span class="arrow right"></span></button><!----></section><!--]--></li></ul><!--[--><!----><!--]--></aside><!--[--><main class="page" id="main-content"><!----><nav class="breadcrumb disable"></nav><div class="page-title"><h1><!---->Spring基本原理</h1><div class="page-info"><span class="author-info" aria-label="作者🖊" data-balloon-pos="down" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewbox="0 0 1024 1024" aria-labelledby="author"><title id="author" lang="en">author icon</title><g fill="currentColor"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></g></svg><span><a class="author-item" href="https://zeanzai.me" target="_blank" rel="noopener noreferrer">天晴小猪</a></span><span property="author" content="天晴小猪"></span></span><!----><span class="date-info" aria-label="写作日期📅" data-balloon-pos="down" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewbox="0 0 1024 1024" aria-labelledby="calendar"><title id="calendar" lang="en">calendar icon</title><g fill="currentColor"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></g></svg><span>2023年10月3日</span><meta property="datePublished" content="2023-10-03T10:38:10.000Z"></span><span class="category-info" aria-label="分类🌈" data-balloon-pos="down" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon category-icon" viewbox="0 0 1024 1024" aria-labelledby="category"><title id="category" lang="en">category icon</title><g fill="currentColor"><path d="M148.41 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H148.41c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.311-40.31zM147.556 553.478H429.73c22.263 0 40.311 18.048 40.311 40.31v282.176c0 22.263-18.048 40.312-40.31 40.312H147.555c-22.263 0-40.311-18.049-40.311-40.312V593.79c0-22.263 18.048-40.311 40.31-40.311zM593.927 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H593.927c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.31-40.31zM730.22 920.502H623.926c-40.925 0-74.22-33.388-74.22-74.425V623.992c0-41.038 33.387-74.424 74.425-74.424h222.085c41.038 0 74.424 33.226 74.424 74.067v114.233c0 10.244-8.304 18.548-18.547 18.548s-18.548-8.304-18.548-18.548V623.635c0-20.388-16.746-36.974-37.33-36.974H624.13c-20.585 0-37.331 16.747-37.331 37.33v222.086c0 20.585 16.654 37.331 37.126 37.331H730.22c10.243 0 18.547 8.304 18.547 18.547 0 10.244-8.304 18.547-18.547 18.547z"></path></g></svg><ul class="categories-wrapper"><li class="category category3 clickable" role="navigation">arch</li><meta property="articleSection" content="arch"></ul></span><span aria-label="标签🏷" data-balloon-pos="down" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon tag-icon" viewbox="0 0 1024 1024" aria-labelledby="tag"><title id="tag" lang="en">tag icon</title><g fill="currentColor"><path d="M939.902 458.563L910.17 144.567c-1.507-16.272-14.465-29.13-30.737-30.737L565.438 84.098h-.402c-3.215 0-5.726 1.005-7.634 2.913l-470.39 470.39a10.004 10.004 0 000 14.164l365.423 365.424c1.909 1.908 4.42 2.913 7.132 2.913s5.223-1.005 7.132-2.913l470.39-470.39c2.01-2.11 3.014-5.023 2.813-8.036zm-240.067-72.121c-35.458 0-64.286-28.828-64.286-64.286s28.828-64.285 64.286-64.285 64.286 28.828 64.286 64.285-28.829 64.286-64.286 64.286z"></path></g></svg><ul class="tags-wrapper"><li class="tag tag5 clickable" role="navigation">spring</li></ul><meta property="keywords" content="spring"></span><span class="reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="down" pageview="false"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewbox="0 0 1024 1024" aria-labelledby="timer"><title id="timer" lang="en">timer icon</title><g fill="currentColor"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></g></svg><span>大约 20 分钟</span><meta property="timeRequired" content="PT20M"></span></div><hr></div><div class="toc-place-holder"><aside id="toc-list"><div class="toc-header">此页内容</div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/java/arch/spring00.html#spring-知识点提纲" class="router-link-active router-link-exact-active toc-link level2">Spring 知识点提纲</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/java/arch/spring00.html#spring为什么如此重要" class="router-link-active router-link-exact-active toc-link level2">Spring为什么如此重要？</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/java/arch/spring00.html#危机一" class="router-link-active router-link-exact-active toc-link level3">危机一</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/java/arch/spring00.html#危机二" class="router-link-active router-link-exact-active toc-link level3">危机二</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/java/arch/spring00.html#总结" class="router-link-active router-link-exact-active toc-link level3">总结</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/java/arch/spring00.html#spring的核心原理" class="router-link-active router-link-exact-active toc-link level2">Spring的核心原理</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/java/arch/spring00.html#spring的组件" class="router-link-active router-link-exact-active toc-link level2">Spring的组件</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/java/arch/spring00.html#容器" class="router-link-active router-link-exact-active toc-link level2">容器</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/java/arch/spring00.html#bean-相关" class="router-link-active router-link-exact-active toc-link level2">Bean 相关</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/java/arch/spring00.html#bean的生命周期" class="router-link-active router-link-exact-active toc-link level3">Bean的生命周期</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/java/arch/spring00.html#bean的元信息" class="router-link-active router-link-exact-active toc-link level3">Bean的元信息</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/java/arch/spring00.html#把元数据提供给-spring-容器" class="router-link-active router-link-exact-active toc-link level3">把元数据提供给 Spring 容器</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/java/arch/spring00.html#bean的依赖注入的方式" class="router-link-active router-link-exact-active toc-link level3">Bean的依赖注入的方式</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/java/arch/spring00.html#产生的背景" class="router-link-active router-link-exact-active toc-link level2">产生的背景</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/java/arch/spring00.html#spring产生的背景" class="router-link-active router-link-exact-active toc-link level2">Spring产生的背景</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/java/arch/spring00.html#bean-的注册" class="router-link-active router-link-exact-active toc-link level2">Bean 的注册</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/java/arch/spring00.html#bean的分类" class="router-link-active router-link-exact-active toc-link level3">Bean的分类</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/java/arch/spring00.html#容器的实现原理" class="router-link-active router-link-exact-active toc-link level3">容器的实现原理</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/java/arch/spring00.html#管理和组织bean的规则" class="router-link-active router-link-exact-active toc-link level3">管理和组织Bean的规则</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/java/arch/spring00.html#springboot-的自动装配" class="router-link-active router-link-exact-active toc-link level3">Springboot 的自动装配</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/java/arch/spring00.html#bean的作用域" class="router-link-active router-link-exact-active toc-link level2">Bean的作用域</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/java/arch/spring00.html#什么是bean的作用域" class="router-link-active router-link-exact-active toc-link level3">什么是Bean的作用域</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/java/arch/spring00.html#提纲" class="router-link-active router-link-exact-active toc-link level2">提纲</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/java/arch/spring00.html#_0-spring为什么如此重要" class="router-link-active router-link-exact-active toc-link level2">0.Spring为什么如此重要？</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/java/arch/spring00.html#前置知识" class="router-link-active router-link-exact-active toc-link level3">前置知识</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/java/arch/spring00.html#实验" class="router-link-active router-link-exact-active toc-link level3">实验</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/java/arch/spring00.html#丐版spring" class="router-link-active router-link-exact-active toc-link level3">丐版Spring</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/java/arch/spring00.html#类与类之间的关系" class="router-link-active router-link-exact-active toc-link level2">类与类之间的关系</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/java/arch/spring00.html#使用spring" class="router-link-active router-link-exact-active toc-link level2">使用Spring</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/java/arch/spring00.html#bean-配置元信息的方式" class="router-link-active router-link-exact-active toc-link level2">Bean 配置元信息的方式</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/java/arch/spring00.html#概念" class="router-link-active router-link-exact-active toc-link level2">概念</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/java/arch/spring00.html#依赖注入" class="router-link-active router-link-exact-active toc-link level2">依赖注入</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/java/arch/spring00.html#学习资料" class="router-link-active router-link-exact-active toc-link level2">学习资料</a></li><!----><!--]--></ul></div></aside></div><!----><div class="theme-hope-content"><!--[--><h2 id="spring-知识点提纲" tabindex="-1"><a class="header-anchor" href="#spring-知识点提纲" aria-hidden="true">#</a> Spring 知识点提纲</h2><ul><li>Spring产生的背景及其特点</li><li>组件及其各自作用</li><li>容器高级视图</li><li>IOC容器的实现（BeanFactory）及其子类</li><li>ApplicationFactory及其子类</li><li>WebApplicationContext功能</li><li>注解及其作用</li><li>标准事件分类（5种）</li><li>Bean <ul><li>属性</li><li>5种作用域</li><li>在Spring应用上下文中的生命周期</li><li>装配方式（手工装配、自动装配）</li><li>Bean后置处理器作用及用法</li></ul></li><li>AOP定义及相关术语、实现方式、基本原理、相关设计模式</li><li>事务管理、隔离级别、传播机制</li></ul><blockquote><p>软件研发过程： 背景描述，需求设计，概要设计，详细设计……因此在学习Spring时，可以把Spring看作是一个业务需求，只不过这个业务需求是要完成对我们写的各种各样的Java类的管理。</p></blockquote><h2 id="spring为什么如此重要" tabindex="-1"><a class="header-anchor" href="#spring为什么如此重要" aria-hidden="true">#</a> Spring为什么如此重要？</h2><p>我们先来看一下，在Spring还没有出现之前，整个软件过程中所存在的“危机”。</p><h3 id="危机一" tabindex="-1"><a class="header-anchor" href="#危机一" aria-hidden="true">#</a> 危机一</h3><p>例如，使用早期的Java技术来实现Web应用时，我们会这样实现：</p><ol><li>使用idea创建一个web项目</li><li>创建servlet，servlet中写业务代码，组装需要数据，将数据以json格式输出</li><li>在web.xml中配置servlet信息</li><li>将项目部署到tomcat中</li></ol><p>分析一下上面这种开发方式：</p><ul><li>与业务相关的只有第2步中的“业务代码”部分，其余步骤均为非业务相关的技术步骤——非业务相关的技术步骤过于复杂；</li><li>当有很多个web模块时，每个模块都要重复1/3/4步骤——非业务相关的技术步骤过于重复；</li></ul><p>因此，我们会发现，在Spring还没有出现之前的第一个软件危机，即： <strong>软件过程中，非业务相关的技术步骤过于复杂与重复。</strong></p><h3 id="危机二" tabindex="-1"><a class="header-anchor" href="#危机二" aria-hidden="true">#</a> 危机二</h3><p>再比如，我们想要使用上面的技术来完成某个业务功能时，可能会有这样的情况：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>public class A{
    public void m1(){}
}
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>假如，我们想要在B中调用A中的m1()方法，那么我们可以这样做：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>public class B{
    private A a; // @1
    public B(){
        this.a = new A(); //@2 此时，A的构造过程是由B控制的
    }
    public void m1(){
        this.a.m1(); //@3
    }
}

// 使用的过程是这样的：
test(){
    B b = new B();
    b.m1();
}
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>但是随着业务的发展，我们会发现上面这种方式不利于扩展，于是我们把原来在A的构造过程交出去，让使用B的使用者随意的组织A的构造过程，于是我们这样实现：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>public class B{
    private A a;
    public B(A a){
        this.a = a;
    }
    public void m1(){
        this.a.m1(); 
    }
}

test(){
    A a = new A();  // 把A的构造过程交给了使用者test()
    B b = new B(a);
    b.m1();
}
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>但是随着业务的发展，我们又发现，上面这种方式也不利于扩展，例如如果B中依赖很多的类似于A的对象，比如需要依赖于C、D、E、F或者更多对象，那么我们首先要调整B的构造方法，其次还要调整test()的使用过程，于是代码又变成这样：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>public class B{
    private A a;
    private C c;
    
    private D d;
    private E e;
    public B(A a, C c, D d, E e){
        this.a = a;
        this.c = c;
        this.d = d;
        this.e = e;
    }
    public void m1(){
        this.a.m1(); 
    }
}

test(){
    // A/C/D/E 的构造过程仍然在使用者test()手里
    A a = new A(); 
    C c = new C();
    D d = new D();
    E e = new E();
    B b = new B(a, c, d, e);
    b.m1();
}
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><p>因此，我们会发现，在Spring还没有出现之前的第二个软件危机，即： <strong>编程语言特性决定的bean的构造过程的灵活特性，同时也导致bean的管理与维护不够标准和规范。</strong></p><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h3><p>传统的软件工程中存在“危机”：</p><ul><li><strong>软件过程中，非业务相关的技术步骤过于复杂与重复。</strong></li><li><strong>编程语言特性决定的bean的构造过程的灵活特性，同时也导致bean的管理与维护不够标准和规范。</strong></li></ul><p>而Spring的出现，彻底解决了上面的这些问题。</p><h2 id="spring的核心原理" tabindex="-1"><a class="header-anchor" href="#spring的核心原理" aria-hidden="true">#</a> Spring的核心原理</h2><p>核心原理分成几个步骤：</p><ol><li>把Bean简单化，简单到只完成具体的业务功能，简单的实现思路就是把通用功能和具体的业务功能进行剥离，然后形成一个个独立的Bean。结果就涉及到另外一个问题： 如何管理这些单个独立的Bean，答案是： 构造一个管理所有Bean的组件并实现控制反转（IoC），即实现一个组件，让这个组件具有管理所有Bean的功能，并且这个组件能够控制Bean的生命周期（即Bean的构造和销毁，以及中间的使用过程）。</li><li>完成上面的步骤后，还涉及到另外两个问题： <ol><li>如何把剥离出来的通用功能（如日志管理功能、安全控制功能）重新组织回Bean；</li><li>如何组织和管理不同Bean复用； 解决上面两个问题的思路是： 依赖注入（DI），即把这些通用的功能使用某种技术注入到Bean中，具体的实现技术是： 动态代理，思路是在运行期动态生成新的Java代码，让Java代码重新具有完成所有的功能。</li></ol></li></ol><blockquote><p>动态代理 vs 静态代理：</p></blockquote><h2 id="spring的组件" tabindex="-1"><a class="header-anchor" href="#spring的组件" aria-hidden="true">#</a> Spring的组件</h2><p>Core AOP Transaction</p><h2 id="容器" tabindex="-1"><a class="header-anchor" href="#容器" aria-hidden="true">#</a> 容器</h2><p>利用控制反转（IoC）的设计思想，剥夺程序员对Bean的部分控制权，并把这些被剥夺的控制权给到Spring。于是，Spring就要提供管理这些控制权的解决方案，这个解决方案就是容器。</p><p>所谓容器，就是说Spring提供了一个类似于数据库的功能，只不过这个功能保存的是JavaBean。</p><p><img src="https://tianqingxiaozhu.oss-cn-shenzhen.aliyuncs.com/20230920110214.png" alt="20230920110214" loading="lazy"></p><p>如上图，步骤解析如下：</p><ol><li>读取各种各样的配置文件，从中获取各种各样的pojo；</li><li>Spring容器就从这些配置文件中，获得pojo的文件所在位置，并生成一个 Bean 的注册表；</li><li>Spring容器会根据 Bean的注册表 实例化Bean，并把实例化后的bean放入 Bean 缓存池里面，以便后续的使用；</li></ol><blockquote><p>IoC容器的启动源码解析过程：</p></blockquote><h2 id="bean-相关" tabindex="-1"><a class="header-anchor" href="#bean-相关" aria-hidden="true">#</a> Bean 相关</h2><p>单个Bean的构造权，通过元信息提供给Spring容器，并由Spring容器进行构造。即Spring容器剥夺了Bean的构造权。</p><p>多个Bean之间组合使用，由此产生的依赖关系的装配权，可以由Spring来管理，也可以由开发人员来管理；</p><h3 id="bean的生命周期" tabindex="-1"><a class="header-anchor" href="#bean的生命周期" aria-hidden="true">#</a> Bean的生命周期</h3><p>// TODO</p><h3 id="bean的元信息" tabindex="-1"><a class="header-anchor" href="#bean的元信息" aria-hidden="true">#</a> Bean的元信息</h3><p><img src="https://tianqingxiaozhu.oss-cn-shenzhen.aliyuncs.com/20230926185926.png" alt="20230926185926" loading="lazy"></p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>class</td><td>这个属性是强制性的，并且指定用来创建 bean 的 bean 类。</td></tr><tr><td>name</td><td>这个属性指定唯一的 bean 标识符。在基于 XML 的配置元数据中，你可以使用 ID 和/或 name 属性来指定 bean 标识符。</td></tr><tr><td>scope</td><td>这个属性指定由特定的 bean 定义创建的对象的作用域，它将会在 bean 作用域的章节中进行讨论。</td></tr><tr><td>constructor-arg</td><td>它是用来注入依赖关系的，并会在接下来的章节中进行讨论。</td></tr><tr><td>properties</td><td>它是用来注入依赖关系的，并会在接下来的章节中进行讨论。</td></tr><tr><td>autowiring mode</td><td>它是用来注入依赖关系的，并会在接下来的章节中进行讨论。</td></tr><tr><td>lazy-initialization mode</td><td>延迟初始化的 bean 告诉 IoC 容器在它第一次被请求时，而不是在启动时去创建一个 bean 实例。</td></tr><tr><td>initialization 方法</td><td>在 bean 的所有必需的属性被容器设置之后，调用回调方法。它将会在 bean 的生命周期章节中进行讨论。</td></tr><tr><td>destruction 方法</td><td>当包含该 bean 的容器被销毁时，使用回调方法。它将会在 bean 的生命周期章节中进行讨论。</td></tr></tbody></table><h4 id="scope" tabindex="-1"><a class="header-anchor" href="#scope" aria-hidden="true">#</a> scope</h4><ul><li>singleton <ul><li>描述：该作用域下的 Bean 在 IoC 容器中只存在一个实例：获取 Bean（即通过 applicationContext.getBean等方法获取）及装配 Bean（即通过 @Autowired 注入）都是同一个对象；</li><li>场景：通常无状态的 Bean 使用该作用域，无状态表示 Bean 对象的属性状态不需要更新；</li><li>备注：Spring 默认选择该作用域，线程不安全，Spring使用ThreadLocal解决线程安全问题；</li></ul></li><li>prototype <ul><li>描述：每次对该作用域下的 Bean 的请求都会创建新的实例：获取 Bean（即通过 applicationContext.getBean 等方法获取）及装配 Bean（即通过 @Autowired 注入）都是新的对象实例。</li><li>场景：通常有状态的 Bean 使用该作用域。</li></ul></li><li>request <ul><li>描述：每次 Http 请求会创建新的 Bean 实例，且创建的Bean实例只对当前 Http 请求有效，Http 请求结束，改Bean实例也被销毁；类似于 prototype。</li><li>场景：一次 Http 的请求和响应的共享 Bean。</li><li>备注：限定 Spring MVC 框架中使用。</li></ul></li><li>session <ul><li>描述：在一个 Http Session 中，定义一个 Bean 实例，不同的 Session 中不共享Bean实例；</li><li>场景：用户会话的共享 Bean, 比如：记录一个用户的登陆信息。</li><li>备注：限定 Spring MVC 框架中使用。</li></ul></li><li>application <ul><li>描述：在一个 Http Servlet Context 中，定义一个 Bean 实例。</li><li>场景：Web 应用的上下文信息，比如：记录一个应用的共享信息。</li><li>备注：限定 Spring MVC 框架中使用。</li></ul></li></ul><p>设置Bean的Scope属性的方法：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>&lt;bean id=&quot;book02&quot; class=&quot;com.spring.beans.Book&quot; scope=&quot;singleton&quot;&gt;&lt;/bean&gt;
&lt;bean id=&quot;book02&quot; class=&quot;com.spring.beans.Book&quot; scope=&quot;prototype&quot;&gt;&lt;/bean&gt;
&lt;bean id=&quot;book02&quot; class=&quot;com.spring.beans.Book&quot; scope=&quot;request&quot;&gt;&lt;/bean&gt;
&lt;bean id=&quot;book02&quot; class=&quot;com.spring.beans.Book&quot; scope=&quot;session&quot;&gt;&lt;/bean&gt;
&lt;bean id=&quot;book02&quot; class=&quot;com.spring.beans.Book&quot; scope=&quot;application&quot;&gt;&lt;/bean&gt;
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><img src="https://tianqingxiaozhu.oss-cn-shenzhen.aliyuncs.com/20230926195526.png" alt="20230926195526" loading="lazy"></p><p>bean的状态：</p><p>无状态bean和有状态bean</p><p>有状态就是有数据存储功能。有状态对象(Stateful Bean)，就是有实例变量的对象，可以保存数据，是非线程安全的。在不同方法调用间不保留任何状态。 无状态就是一次操作，不能保存数据。无状态对象(Stateless Bean)，就是没有实例变量的对象 .不能保存数据，是不变类，是线程安全的。</p><p>参考<a href="https://www.cnblogs.com/vipstone/p/16641846.html" target="_blank" rel="noopener noreferrer">链接<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><p>Spring中出现同名bean怎么办？</p><h4 id="autowiring" tabindex="-1"><a class="header-anchor" href="#autowiring" aria-hidden="true">#</a> autowiring</h4><p>no - 这是默认设置，表示没有自动装配。应使用显式 bean 引用进行装配。 byName - 它根据 bean 的名称注入对象依赖项。它匹配并装配其属性与 XML 文件中由相同名称定义的 bean。 byType - 它根据类型注入对象依赖项。如果属性的类型与 XML 文件中的一个 bean 名称匹配，则匹配并装配属性。 构造函数 - 它通过调用类的构造函数来注入依赖项。它有大量的参数。 autodetect - 首先容器尝试通过构造函数使用 autowire 装配，如果不能，则尝试通过 byType 自动装配。</p><h4 id="lazy-initialization" tabindex="-1"><a class="header-anchor" href="#lazy-initialization" aria-hidden="true">#</a> lazy-initialization</h4><p>在bean定义的时候通过lazy-init属性来配置bean是否是延迟加载，true：延迟初始化，false：实时初始化</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>&lt;bean lazy-init=&quot;是否是延迟初始化&quot; /&gt;

@Lazy 注解
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="把元数据提供给-spring-容器" tabindex="-1"><a class="header-anchor" href="#把元数据提供给-spring-容器" aria-hidden="true">#</a> 把元数据提供给 Spring 容器</h3><p>有三种方式：</p><ul><li>基于 XML 的配置文件</li><li>基于注解的配置</li><li>基于 Java 的配置</li></ul><p><img src="https://tianqingxiaozhu.oss-cn-shenzhen.aliyuncs.com/20230926190636.png" alt="20230926190636" loading="lazy"></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>&lt;bean id=&quot;book02&quot; class=&quot;com.spring.beans.Book&quot; scope=&quot;singleton&quot;&gt;&lt;/bean&gt;
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><h3 id="bean的依赖注入的方式" tabindex="-1"><a class="header-anchor" href="#bean的依赖注入的方式" aria-hidden="true">#</a> Bean的依赖注入的方式</h3><ul><li>构造方法</li><li>set方式</li><li>静态工厂方法</li><li>实例工厂方法</li></ul><hr><h2 id="产生的背景" tabindex="-1"><a class="header-anchor" href="#产生的背景" aria-hidden="true">#</a> 产生的背景</h2><p>早期的软件设计中，Java类的管理很混乱，比如说，我们创建了一个Student类，类里面包括了一些属性和一些简单方法，于是我们在使用的过程中，就是简单的去new一个对象出来。</p><p>但是随着软件的发展，我们对Student类的要求越来越多，比如：</p><ol><li>在类生成的时候记录一下所有属性的值；</li><li>在类销毁的时候给Teacher类发送一个通知；</li><li>在创建这个类的实例对象时，还要提前创建一个Clazz类，表示这个学生所属的班级信息；</li><li>……</li></ol><p>我们就会发现，这个Student类会越来越复杂。这就使得我们对Java类的管理失去了控制。于是人们就想有没有一种方法来解决上面的这些问题。于是Spring就产生了。</p><h2 id="spring产生的背景" tabindex="-1"><a class="header-anchor" href="#spring产生的背景" aria-hidden="true">#</a> Spring产生的背景</h2><p>早期的面向对象的软件过程中，类的管理完全是需要程序员自定义去实现的，随着系统的迭代，类就会膨胀，也会变得越来越复杂，最终导致软件系统失去控制。</p><p>计算机大神们研发了一款软件，可以管理程序员自定义的各种类，这款软件产品就是Spring。</p><p>这款软件产品完成了本来需要程序员完成的功能，例如：</p><ol><li>单个Bean的生命周期管理；</li><li>多个Bean的组织和装配，说白了就是能够处理多个Bean之间的相互依赖关系，何时构造、何时组织和装配；</li></ol><blockquote><p>组织和装配： 比如 Student 类中有一个 Class 类，表明学生所属的班级信息，我们自定义实现时，会new一个class对象，然后把这个class对象传给student作为student的构造参数。有了Spring之后就只需要写Student类和Class类，这二者之间的组织过程和装配过程就交给Spring来处理了。</p></blockquote><h2 id="bean-的注册" tabindex="-1"><a class="header-anchor" href="#bean-的注册" aria-hidden="true">#</a> Bean 的注册</h2><p>盛放Bean的容器已经创建好了，下一个步骤就是把Bean放到容器中，把Bean放到容器中的过程就是Bean的注册。</p><h3 id="bean的分类" tabindex="-1"><a class="header-anchor" href="#bean的分类" aria-hidden="true">#</a> Bean的分类</h3><p>实现容器的各种Java代码本身也是Bean，因此Spring需要管理这些Bean。此外，还有针对具体业务编写的Java代码，这些也是JavaBean，因此Spring也需要管理这些Bean。</p><p>管理Spring框架中自身的Bean的过程是随着Spring的启动的完成而完成的，这个过程，我们在Spring容器的启动过程中来讲解。</p><p>针对具体业务代码编写的JavaBean，我们就需要了解Spring的Bean的装配方式。即Spring是如何把Bean注入到容器中，并完成组织和管理Bean的功能的。</p><p>如果往底层看其原理，就应该是如何构造一个管理和组织Bean的容器，以及如何构建管理和组织Bean的规则，以及如何扩展管理和组织的规则。</p><p>有了Bean工厂以后，我们就可以自由自在的使用各种JavaBean了。我们在Spring项目中使用Bean的方式大概有两种，一种是直接使用Bean，另外一种是把Bean A注入到另外一个Bean B里面，然后使用Bean B。也就是直接使用和间接使用。</p><p>使用间接方式注册到Bean工厂的过程称为装配。（有点像装配车间的概念，把多个模块封装然后分配到各个位置形成统一的整体，然后使用这个整体）。</p><h3 id="容器的实现原理" tabindex="-1"><a class="header-anchor" href="#容器的实现原理" aria-hidden="true">#</a> 容器的实现原理</h3><h3 id="管理和组织bean的规则" tabindex="-1"><a class="header-anchor" href="#管理和组织bean的规则" aria-hidden="true">#</a> 管理和组织Bean的规则</h3><h3 id="springboot-的自动装配" tabindex="-1"><a class="header-anchor" href="#springboot-的自动装配" aria-hidden="true">#</a> Springboot 的自动装配</h3><p>什么是装配？</p><p>Spring Boot中的自动装配技术底层主要用到了下面这些技术:</p><p>Spring 模式注解装配</p><p>Spring @Enable 模块装配</p><p>Spring 条件装配装（深入学习Spring组件注册中有介绍）</p><p>Spring 工厂加载机制</p><h2 id="bean的作用域" tabindex="-1"><a class="header-anchor" href="#bean的作用域" aria-hidden="true">#</a> Bean的作用域</h2><h3 id="什么是bean的作用域" tabindex="-1"><a class="header-anchor" href="#什么是bean的作用域" aria-hidden="true">#</a> 什么是Bean的作用域</h3><hr><h2 id="提纲" tabindex="-1"><a class="header-anchor" href="#提纲" aria-hidden="true">#</a> 提纲</h2><ul><li>【背景】EJB开发模式及其弊端</li><li>【愿景】造一个能帮助程序员管理各种JavaBean组件的容器</li><li>【实现】Spring框架 <ul><li>功能特性</li><li>简单使用过程</li><li>模块及其各自功能特性： Core、Context、AOP、Web、DAO、MVC、ORM</li><li>原理</li><li>好处</li></ul></li><li>Bean相关 <ul><li>概念： 什么是POJO、组件、Bean等；</li><li>元信息： <ul><li>基本信息</li><li>行为信息</li><li>依赖信息</li><li>延伸 对bean元信息的讲解</li></ul></li><li>描述Bean的元信息的方式 <ul><li>xml</li><li>Java直接编码 <ul><li>基于注解</li><li>基于SpringAPI方式</li></ul></li><li>GroovyDSL方式</li><li>【待定】使用 Spring 官方提供的注解 <ul><li>有哪些注解，这些注解的功能是什么</li></ul></li></ul></li><li>如何实现依赖关系 <ul><li>基于Spring： Spring的自动装配</li><li>自行实现： 构造方法，set方法，简单工厂方法、静态工厂方法</li></ul></li><li>Bean的生命周期</li><li>面试题 <ul><li>如何解决循环依赖？</li><li>Spring中同名Bean的处理方式？</li><li>单例Bean的线程同步问题？</li><li>为什么要有Bean的生命周期，基于Bean的生命周期能完成什么企业级功能？</li></ul></li></ul></li></ul><h2 id="_0-spring为什么如此重要" tabindex="-1"><a class="header-anchor" href="#_0-spring为什么如此重要" aria-hidden="true">#</a> 0.Spring为什么如此重要？</h2><h3 id="前置知识" tabindex="-1"><a class="header-anchor" href="#前置知识" aria-hidden="true">#</a> 前置知识</h3><p>在没有出现Spring之前，EJB是大型企业级应用的主要技术选型。但EJB有着很大的问题：</p><ol><li>整个软件过程中，非业务相关的技术步骤过于复杂与重复。比如每开发一个模块就都需要创建servlet、web.xml等，还需要重量级容器作为支撑等；</li><li>EJB并没有对Bean的管理和维护设置统一标准，这使得Bean的管理和维护极其混乱；</li><li>EJB的交叉业务实现过程复杂。比如安全控制、日志记录、事务控制等交叉业务，需要在每个需求中都要进行实现；</li><li>EJB项目难以测试；</li><li>......</li></ol><blockquote><p>EJB的技术，通俗点讲，就是想方设法实现一个又一个的可复用的JavaBean组件。但是这个过程中需要程序员自行实现，而由于程序员技术素养的差别以及Java语言的灵活性特点，这又导致Bean的实现过程千差万别，最终导致软件系统难以维护。</p></blockquote><p>以上问题，最终抽象并总结起来就是： <code>Bean的构造权和Bean的依赖关系的控制权</code> 的归属问题。即传统的软件开发过程中，<code>Bean的构造权和Bean的依赖关系的控制权</code>等均由负责开发的程序员来完成，由于每个程序员的专业素养的不同以及Java语言的灵活性，就导致Bean的实现方式各式各样，最终导致软件系统失去控制。</p><p>因此，人们就想，能不能造出一种工具，这种工具能让程序员从复杂而又灵活的实现方式中解脱出来。于是Spring应运而生。事实上，随着时间的发展，Spring也逐渐成为Java企业级应用的“事实标准”。</p><h3 id="实验" tabindex="-1"><a class="header-anchor" href="#实验" aria-hidden="true">#</a> 实验</h3><ol><li>模拟传统开发过程，体会过程中遇到的困难；</li><li>实现一个简易版的Spring，只完成Bean的注册与获取；</li><li>需求变更，要求为每一个接口都提供运行时间的统计功能： <ol><li>通过自行编程的方式实现此需求，体会其中的弊端；</li><li>通过JDK代理技术实现此需求，并分析优缺点；</li><li>通过CGLib代理技术实现此需求，并分析优缺点；</li></ol></li><li>体会基于Spring实现上述需求的实现过程，并分析优缺点；</li></ol><h3 id="丐版spring" tabindex="-1"><a class="header-anchor" href="#丐版spring" aria-hidden="true">#</a> 丐版Spring</h3><ol><li><a href="https://www.cnblogs.com/three-fighter/p/16166891.html" target="_blank" rel="noopener noreferrer">面渣逆袭：Spring三十五问，四万字+五十图详解 <span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li><li><a href="https://www.yuque.com/yguangbxiu/note/zxgf4q#rDMTv" target="_blank" rel="noopener noreferrer">Spring系列课程（1）— 工厂<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li></ol><h2 id="类与类之间的关系" tabindex="-1"><a class="header-anchor" href="#类与类之间的关系" aria-hidden="true">#</a> 类与类之间的关系</h2><blockquote><p>疑问： Spring的依赖注入中的依赖与UML类图中的依赖关系在语义上是一致的吗？</p></blockquote><ul><li><p>Spring提供容器，实现了依赖注入的过程，但对象的构造权和对象关系的维护权，依然可以由程序员自行实现。也就是说对象的创建依然可以由程序员自行维护，这就涉及到采用哪种实现方式为最优解的问题，这个问题换种说话就是：这两种实现方式各自有哪些适用场景，或者说，程序员在业务建模时应当遵守的设计原则有哪些。</p></li><li><p>由UML设计原则知，</p></li><li><p>创建对象的方式及创建对象的时机的选择</p><ul><li>构造方法：</li><li>set方法</li><li>简单工厂方法</li><li>静态工厂方法</li></ul></li></ul><p>参考： <a href="https://www.cnblogs.com/weidagang2046/archive/2009/12/10/1620587.html" target="_blank" rel="noopener noreferrer">Programming.log - a place to keep my thoughts on programming<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p><h2 id="使用spring" tabindex="-1"><a class="header-anchor" href="#使用spring" aria-hidden="true">#</a> 使用Spring</h2><h2 id="bean-配置元信息的方式" tabindex="-1"><a class="header-anchor" href="#bean-配置元信息的方式" aria-hidden="true">#</a> Bean 配置元信息的方式</h2><ul><li>xml</li><li>注解方式</li><li>SpringAPI方式</li><li>properties方式</li></ul><h2 id="概念" tabindex="-1"><a class="header-anchor" href="#概念" aria-hidden="true">#</a> 概念</h2><p>IoC 与 DI</p><p>控制反转（Inversion of Control，缩写为IoC），是面向对象编程中的一种设计思想，可以用来降低代码之间的耦合度，符合依赖倒置原则。 控制反转的核心是：将对象的创建权交出去，将对象和对象之间关系的管理权交出去，由第三方容器来负责创建与维护。 控制反转常见的实现方式：依赖注入（Dependency Injection，简称DI），狭义上讲，依赖注入就是指对象A依赖于对象B的情况；广义上讲，依赖注入也指某一类对象依赖于某一种特定功能的情况，比如项目中所有的接口中都需要添加安全控制的功能。 通常，依赖注入的实现由包括两种方式： ● set方法注入 ● 构造方法注入 而Spring框架就是一个实现了IoC思想的框架。 IoC可以认为是一种全新的设计模式，但是理论和时间成熟相对较晚，并没有包含在GoF中。（GoF指的是23种设计模式）</p><p>● 控制反转是一种思想。 ● 控制反转是为了降低程序耦合度，提高程序扩展力，达到OCP原则，达到DIP原则。 ● 控制反转，反转的是什么？ ○ 将对象的创建权利交出去，交给第三方容器负责。 ○ 将对象和对象之间关系的维护权交出去，交给第三方容器负责。 ● 控制反转这种思想如何实现呢？ ○ DI（Dependency Injection）：依赖注入</p><p>依赖注入 (Dependency Injection) 和自动装配 (Autowiring) 是 Java 程序开发中常用的两种设计模式，它们的作用是解决对象之间的依赖关系。</p><p>依赖注入是一种设计模式，可以将对象的依赖关系从对象本身解耦出来，并使用外部组件来注入依赖关系。这样，对象本身不再需要知道其他对象的细节，也不需要手动创建依赖关系，从而提高了代码的可读性、可维护性和可测试性。</p><p>自动装配是 Spring 框架中的一个特性，它可以自动创建并维护依赖关系，使得开发者不需要手动配置。自动装配可以使用 @Autowired 注解或者 XML 配置方式进行配置，它会自动选择合适的 Bean 用于装配。</p><p>总的来说，依赖注入是一种设计模式，而自动装配是在依赖注入基础上的一种实现方式，它们的目的都是解决对象之间的依赖关系，但自动装配比依赖注入更易于使用。</p><h2 id="依赖注入" tabindex="-1"><a class="header-anchor" href="#依赖注入" aria-hidden="true">#</a> 依赖注入</h2><p>一个BeanA依赖了另外一个BeanB，BeanA并没有BeanB的构造权，只有BeanB的使用权，因此Spring需要把构造好的BeanB重新给到BeanA，这个过程就是依赖注入的过程，通俗点讲，就是Spring把创建好的BeanB的对象重新给回BeanA的过程。</p><p>Spring容器提供了这几种方式： set、构造方法、静态工厂、实例工厂、Autowiring 方式；</p><ul><li>按照是否 需要配置Bean之间的依赖信息 ，把依赖注入划分为：手动模式 和 自动模式： <ul><li>手动模式 - 配置或者编程的方式，提前安排注入规则 <ul><li>XML 资源配置元信息</li><li>Java 注解配置元信息</li><li>API 配置元信息</li></ul></li><li>自动模式 - 实现方提供依赖自动关联的方式，按照內建的注入规则 <ul><li>Autowiring（自动绑定）</li></ul></li></ul></li><li>按照 被依赖者 的 <ul><li>setter</li><li>构造方法</li><li>静态工厂</li><li>实例工厂</li></ul></li></ul><h2 id="学习资料" tabindex="-1"><a class="header-anchor" href="#学习资料" aria-hidden="true">#</a> 学习资料</h2><ol><li>Spring实战（第5版）【文字版】 (克雷格·沃斯) (z-lib.org).pdf</li><li>Spring高手系列.pdf https://gitee.com/javacode2018/spring-series</li><li>Spring 5核心原理与30个类手写实战@www.cmsblogs.cn.pdf</li></ol><ul><li><a href="https://github.com/wuyouzhuguli/SpringAll" target="_blank" rel="noopener noreferrer">此文<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> 中关于Spring原理部分</li><li><a href="https://doocs.github.io/source-code-hunter/#/" target="_blank" rel="noopener noreferrer">此文<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a> 中关于Spring原理部分</li><li><a href="https://mp.weixin.qq.com/s/Y17S85ntHm_MLTZMJdtjQQ" target="_blank" rel="noopener noreferrer">Spring三十五问，四万字+五十图详解！建议收藏！<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></li></ul><hr><br><br><br><img style="border:1px red solid;display:block;margin:0 auto;" src="https://tianqingxiaozhu.oss-cn-shenzhen.aliyuncs.com/img/qrcode.jpg" alt="微信公众号"><!--]--></div><!----><footer class="page-meta"><div class="meta-item edit-link"><a href="https://github.com/zeanzai/zeanzai.github.io/edit/main/docs/java/arch/spring00.md" rel="noopener noreferrer" target="_blank" aria-label="编辑此页" class="nav-link label"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewbox="0 0 1024 1024" aria-labelledby="edit"><title id="edit" lang="en">edit icon</title><g fill="currentColor"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></g></svg><!--]-->编辑此页<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="meta-item update-time"><span class="label">上次编辑于: </span><span class="info">2023/10/23 00:44:48</span></div><div class="meta-item contributors"><span class="label">贡献者: </span><!--[--><!--[--><span class="contributor" title="email: zeanzai.me@gmail.com">zeanzai</span><!--]--><!--]--></div></footer><!----><div class="giscus-wrapper input-top" style="display:block;"><giscus-widget repo="zeanzai/zeanzai.github.io" repoId="R_kgDOI84HVQ" category="Announcements" categoryId="DIC_kwDOI84HVc4CUKFF" lang="zh-CN" theme="light" mapping="pathname" inputPosition="top" reactionsEnabled="1" emitMetadata="0"></giscus-widget></div><!----></main><!--]--><footer class="footer-wrapper"><div class="footer">浪漫骑士的二流键盘</div><div class="copyright">Copyright © 2023 天晴小猪</div></footer></div><!--]--><!----><!--]--></div>
    <script type="module" src="/assets/app.42286db3.js" defer></script>
  </body>
</html>
